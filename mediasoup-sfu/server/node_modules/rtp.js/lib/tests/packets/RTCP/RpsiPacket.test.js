"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RpsiPacket_1 = require("../../../packets/RTCP/RpsiPacket");
const FeedbackPacket_1 = require("../../../packets/RTCP/FeedbackPacket");
const RtcpPacket_1 = require("../../../packets/RTCP/RtcpPacket");
const helpers_1 = require("../../../utils/helpers");
const rpsiPacketDump = {
    byteLength: 24,
    padding: 0,
    packetType: RtcpPacket_1.RtcpPacketType.PSFB,
    count: 3,
    messageType: FeedbackPacket_1.PsFeedbackMessageType.RPSI,
    senderSsrc: 0x11223344,
    mediaSsrc: 0x55667788,
    payloadType: 120,
    bitStringLength: 8,
    paddingBits: 16
};
const array = new Uint8Array([
    0x83, 0xce, 0x00, 0x05,
    0x11, 0x22, 0x33, 0x44,
    0x55, 0x66, 0x77, 0x88,
    0x10, 0x78, 0x11, 0x22,
    0x33, 0x44, 0x55, 0x66,
    0x77, 0x88, 0x00, 0x00 // Bit String, FCI Padding (2 Bytes)
]);
const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
const bitStringView = new DataView(array.buffer, array.byteOffset + 14, 8);
describe('parse RTCP RPSI packet', () => {
    test('buffer view is RTCP', () => {
        expect((0, RtcpPacket_1.isRtcp)(view)).toBe(true);
    });
    test('packet processing succeeds', () => {
        const packet = new RpsiPacket_1.RpsiPacket(view);
        expect(packet.needsSerialization()).toBe(false);
        expect(packet.dump()).toEqual(rpsiPacketDump);
        expect((0, helpers_1.areDataViewsEqual)(packet.getView(), view)).toBe(true);
        expect((0, helpers_1.areDataViewsEqual)(packet.getBitString(), bitStringView)).toBe(true);
        packet.serialize();
        expect(packet.needsSerialization()).toBe(false);
        expect(packet.dump()).toEqual(rpsiPacketDump);
        expect((0, helpers_1.areDataViewsEqual)(packet.getView(), view)).toBe(true);
        expect((0, helpers_1.areDataViewsEqual)(packet.getBitString(), bitStringView)).toBe(true);
        const clonedPacket = packet.clone();
        expect(clonedPacket.needsSerialization()).toBe(false);
        expect(clonedPacket.dump()).toEqual(rpsiPacketDump);
        expect((0, helpers_1.areDataViewsEqual)(clonedPacket.getView(), view)).toBe(true);
        expect((0, helpers_1.areDataViewsEqual)(clonedPacket.getBitString(), bitStringView)).toBe(true);
    });
});
describe('create RTCP RPSI packet', () => {
    const packet = new RpsiPacket_1.RpsiPacket();
    test('packet view is RTCP', () => {
        expect((0, RtcpPacket_1.isRtcp)(packet.getView())).toBe(true);
    });
    test('packet processing succeeds', () => {
        // First just fill mandatory fields so serialization should not be needed.
        packet.setSenderSsrc(rpsiPacketDump.senderSsrc);
        packet.setMediaSsrc(rpsiPacketDump.mediaSsrc);
        expect(packet.needsSerialization()).toBe(false);
        expect(packet.dump()).toEqual({
            ...rpsiPacketDump,
            byteLength: 16,
            payloadType: 0,
            bitStringLength: 2,
            paddingBits: 0
        });
        // Fill optional fields so serialization should be needed.
        packet.setPayloadType(rpsiPacketDump.payloadType);
        packet.setBitString((0, helpers_1.numericArrayToDataView)([0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88]));
        expect(packet.needsSerialization()).toBe(true);
        expect(packet.dump()).toEqual(rpsiPacketDump);
        expect((0, helpers_1.areDataViewsEqual)(packet.getView(), view)).toBe(true);
        expect((0, helpers_1.areDataViewsEqual)(packet.getBitString(), bitStringView)).toBe(true);
        packet.serialize();
        expect(packet.needsSerialization()).toBe(false);
        expect(packet.dump()).toEqual(rpsiPacketDump);
        expect((0, helpers_1.areDataViewsEqual)(packet.getView(), view)).toBe(true);
        expect((0, helpers_1.areDataViewsEqual)(packet.getBitString(), bitStringView)).toBe(true);
        const clonedPacket = packet.clone();
        expect(clonedPacket.needsSerialization()).toBe(false);
        expect(clonedPacket.dump()).toEqual(rpsiPacketDump);
        expect((0, helpers_1.areDataViewsEqual)(clonedPacket.getView(), view)).toBe(true);
        expect((0, helpers_1.areDataViewsEqual)(clonedPacket.getBitString(), bitStringView)).toBe(true);
    });
});
