"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const XrPacket_1 = require("../../../packets/RTCP/XrPacket");
const RtcpPacket_1 = require("../../../packets/RTCP/RtcpPacket");
const ExtendedReport_1 = require("../../../packets/RTCP/ExtendedReports/ExtendedReport");
const LrleExtendedReport_1 = require("../../../packets/RTCP/ExtendedReports/LrleExtendedReport");
const chunks_1 = require("../../../packets/RTCP/ExtendedReports/chunks");
const helpers_1 = require("../../../utils/helpers");
const runLengthZerosChunk = 0b0010101010101010;
const runLengthOnesChunk = 0b0110101010101010;
const bitVectorChunk = 0b1110101010101010;
const terminatingNullChunk = 0b0000000000000000;
const report1Dump = {
    byteLength: 20,
    reportType: ExtendedReport_1.ExtendedReportType.LRLE,
    thinning: 9,
    ssrc: 0x03932db4,
    beginSeq: 0x11,
    endSeq: 0x22,
    chunks: [runLengthZerosChunk, runLengthOnesChunk, bitVectorChunk]
};
const packetDump = {
    byteLength: 32,
    padding: 4,
    packetType: RtcpPacket_1.RtcpPacketType.XR,
    count: 0,
    ssrc: 0x5d931534,
    reports: [report1Dump]
};
describe('parse RTCP Receiver Report packet', () => {
    const array = new Uint8Array([
        0xa0, 0xcf, 0x00, 0x07,
        0x5d, 0x93, 0x15, 0x34,
        // Extended Report LRLE
        0x01, 0x09, 0x00, 0x04,
        0x03, 0x93, 0x2d, 0xb4,
        0x00, 0x11, 0x00, 0x22,
        0b00101010, 0b10101010,
        0b01101010, 0b10101010,
        0b11101010, 0b10101010,
        0b00000000, 0b00000000,
        0x00, 0x00, 0x00, 0x04 // Padding (4 bytes)
    ]);
    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    test('buffer view is RTCP', () => {
        expect((0, RtcpPacket_1.isRtcp)(view)).toBe(true);
    });
    test('packet processing succeeds', () => {
        const packet = new XrPacket_1.XrPacket(view);
        expect(packet.needsSerialization()).toBe(false);
        expect(packet.getByteLength()).toBe(32);
        expect(packet.getPacketType()).toBe(RtcpPacket_1.RtcpPacketType.XR);
        // No count field in XR packetd, so this must be 0.
        expect(packet.getCount()).toBe(0);
        expect(packet.getPadding()).toBe(4);
        expect(packet.getSsrc()).toBe(0x5d931534);
        expect(packet.getReports().length).toBe(1);
        expect(packet.dump()).toEqual(packetDump);
        expect((0, helpers_1.areDataViewsEqual)(packet.getView(), view)).toBe(true);
        const report1 = packet.getReports()[0];
        expect(report1.needsSerialization()).toBe(false);
        expect(report1.getByteLength()).toBe(20);
        expect(report1.getReportType()).toBe(ExtendedReport_1.ExtendedReportType.LRLE);
        expect(report1.getThinning()).toBe(9);
        expect(report1.getSsrc()).toBe(0x03932db4);
        expect(report1.getBeginSeq()).toBe(0x11);
        expect(report1.getEndSeq()).toBe(0x22);
        expect(report1.getChunks()).toEqual([runLengthZerosChunk, runLengthOnesChunk, bitVectorChunk]);
        expect(report1.dump()).toEqual(report1Dump);
    });
});
describe('create RTCP XR packet', () => {
    test('creating a XR packet succeeds', () => {
        const packet = new XrPacket_1.XrPacket();
        expect((0, RtcpPacket_1.isRtcp)(packet.getView())).toBe(true);
        expect(packet.needsSerialization()).toBe(false);
        // Byte length must be 8 (fixed header).
        expect(packet.getByteLength()).toBe(8);
        expect(packet.getPacketType()).toBe(RtcpPacket_1.RtcpPacketType.XR);
        // No count in RTCP XR packet.
        expect(packet.getCount()).toBe(0);
        expect(packet.getPadding()).toBe(0);
        expect(packet.getSsrc()).toBe(0);
        expect(packet.getReports()).toEqual([]);
        expect(packet.needsSerialization()).toBe(false);
        packet.setSsrc(0x5d931534);
        expect(packet.needsSerialization()).toBe(false);
        const report1 = new LrleExtendedReport_1.LrleExtendedReport();
        expect(report1.needsSerialization()).toBe(false);
        expect(report1.getByteLength()).toBe(12);
        expect(report1.getReportType()).toBe(ExtendedReport_1.ExtendedReportType.LRLE);
        expect(report1.getThinning()).toBe(0);
        expect(report1.getSsrc()).toBe(0);
        expect(report1.getBeginSeq()).toBe(0);
        expect(report1.getEndSeq()).toBe(0);
        expect(report1.getChunks()).toEqual([]);
        report1.setThinning(9);
        report1.setSsrc(0x03932db4);
        report1.setBeginSeq(0x11);
        report1.setEndSeq(0x22);
        report1.addChunk(runLengthZerosChunk);
        report1.addChunk(runLengthOnesChunk);
        report1.addChunk(bitVectorChunk);
        expect(report1.dump()).toEqual(report1Dump);
        expect(report1.needsSerialization()).toBe(true);
        packet.addReport(report1);
        // We cannot add padding to RTCP packets so fix the dump.
        expect(packet.dump()).toEqual({
            ...packetDump,
            byteLength: 28,
            padding: 0
        });
        packet.serialize();
        expect(packet.needsSerialization()).toBe(false);
        expect(report1.needsSerialization()).toBe(false);
        // We cannot add padding to RTCP packets so fix the dump.
        expect(packet.dump()).toEqual({
            ...packetDump,
            byteLength: 28,
            padding: 0
        });
        const clonedPacket = packet.clone();
        expect(clonedPacket.dump()).toEqual({
            ...packetDump,
            byteLength: 28,
            padding: 0
        });
        expect((0, helpers_1.areDataViewsEqual)(clonedPacket.getView(), packet.getView())).toBe(true);
    });
});
describe('chunks parsing and creation', () => {
    test('parseExtendedReportChunk()', () => {
        expect((0, chunks_1.parseExtendedReportChunk)(runLengthZerosChunk)).toEqual({
            chunkType: 'run-length',
            runType: 'zeros',
            runLength: 0b10101010101010
        });
        expect((0, chunks_1.parseExtendedReportChunk)(runLengthOnesChunk)).toEqual({
            chunkType: 'run-length',
            runType: 'ones',
            runLength: 0b10101010101010
        });
        expect((0, chunks_1.parseExtendedReportChunk)(bitVectorChunk)).toEqual({
            chunkType: 'bit-vector',
            bitVector: 0b110101010101010
        });
        expect((0, chunks_1.parseExtendedReportChunk)(terminatingNullChunk)).toEqual({ chunkType: 'terminating-null' });
    });
    test('createExtendedReportRunLengthChunk()', () => {
        expect((0, chunks_1.createExtendedReportRunLengthChunk)('zeros', 0b10101010101010))
            .toBe(runLengthZerosChunk);
        expect((0, chunks_1.createExtendedReportRunLengthChunk)('ones', 0b10101010101010))
            .toBe(runLengthOnesChunk);
    });
    test('createExtendedReportBitVectorChunk()', () => {
        expect((0, chunks_1.createExtendedReportBitVectorChunk)(0b110101010101010))
            .toBe(bitVectorChunk);
    });
});
