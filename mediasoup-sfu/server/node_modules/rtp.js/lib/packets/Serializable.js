"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Serializable_serializationNeeded;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Serializable = void 0;
const helpers_1 = require("../utils/helpers");
/**
 * Class holding a serializable buffer view. All RTP and RTCP packets inherit
 * from this class, and also items in some RTCP packets.
 */
class Serializable {
    constructor(view) {
        // Whether serialization is needed due to recent modifications.
        _Serializable_serializationNeeded.set(this, false);
        if (view) {
            this.view = view;
        }
    }
    /**
     * Serializable dump.
     */
    dump() {
        return {
            byteLength: this.getByteLength()
        };
    }
    /**
     * Get a buffer view containing the serialized content of the packet or item.
     *
     * @param serializationBuffer - Buffer in which the content will be serialized
     *   in case serialization is needed. If not given, a new one will internally
     *   allocated.
     * @param serializationByteOffset - Byte offset of the given `serializationBuffer`
     *   where serialization (if needed) will start.
     *
     * @remarks
     * - The internal buffer is serialized if needed (to apply pending
     * 	 modifications) by internally calling {@link serialize}.
     *
     * @throws
     * - If buffer serialization is needed and it fails due to invalid
     *   content.
     */
    getView(serializationBuffer, serializationByteOffset) {
        if (this.needsSerialization()) {
            this.serialize(serializationBuffer, serializationByteOffset);
        }
        return this.view;
    }
    /**
     * Whether serialization is needed, meaning that the current buffer view
     * doesn't represent the current content of the packet or item (due to
     * modifications not applied yet). Calling {@link serialize} or {@link getView}
     * will serialize the packet or the item.
     */
    needsSerialization() {
        return __classPrivateFieldGet(this, _Serializable_serializationNeeded, "f");
    }
    setSerializationNeeded(flag) {
        __classPrivateFieldSet(this, _Serializable_serializationNeeded, flag, "f");
    }
    /**
     * This method returns a buffer (plus byte offset) for the child to serialize.
     * If a buffer (and optionally a byte offset) is given, this method will verify
     * whether the serialized content can fit into it and will throw otherwise.
     */
    getSerializationBuffer(buffer, byteOffset) {
        byteOffset ?? (byteOffset = 0);
        const byteLength = this.getByteLength();
        if (buffer) {
            if (buffer.byteLength - byteOffset < byteLength) {
                throw new RangeError(`given buffer available space (${buffer.byteLength - byteOffset} bytes) is less than length required for serialization (${byteLength} bytes)`);
            }
            const uint8Array = new Uint8Array(buffer, byteOffset, byteLength);
            // If a buffer is given, ensure the required length is filled with zeroes.
            uint8Array.fill(0);
        }
        else {
            // The buffer is guaranteed to be filled with zeros.
            buffer = new ArrayBuffer(byteLength);
        }
        return { buffer, byteOffset, byteLength };
    }
    cloneInternal(buffer, byteOffset, serializationBuffer, serializationByteOffset) {
        if (this.needsSerialization()) {
            this.serialize(serializationBuffer, serializationByteOffset);
        }
        let view;
        // If buffer is given, let's check whether it holds enough space for the
        // content.
        if (buffer) {
            byteOffset ?? (byteOffset = 0);
            if (buffer.byteLength - byteOffset < this.view.byteLength) {
                throw new RangeError(`given buffer available space (${buffer.byteLength - byteOffset} bytes) is less than length required for clonation (${this.view.byteLength} bytes)`);
            }
            // Copy the content into the given buffer.
            const uint8Array = new Uint8Array(buffer, byteOffset, this.view.byteLength);
            uint8Array.set(new Uint8Array(this.view.buffer, this.view.byteOffset, this.view.byteLength), 0);
            view = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
        }
        else {
            view = (0, helpers_1.clone)(this.view);
        }
        return view;
    }
}
exports.Serializable = Serializable;
_Serializable_serializationNeeded = new WeakMap();
