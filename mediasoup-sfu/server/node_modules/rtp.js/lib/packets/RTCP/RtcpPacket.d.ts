import { Packet, PacketDump } from '../Packet';
/**
 *         0                   1                   2                   3
 *         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * header |V=2|P|    SC   |      PT       |             length            |
 *        +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
 */
export declare const COMMON_HEADER_LENGTH = 4;
/**
 * RTCP packet types.
 *
 * @category RTCP
 */
export declare enum RtcpPacketType {
    /**
     * Extended Jitter Reports packet.
     */
    IJ = 195,
    /**
     * RTCP Sender Report packet.
     */
    SR = 200,
    /**
     * RTCP Receiver Report packet.
     */
    RR = 201,
    /**
     * RTCP Sender Report packet.
     */
    SDES = 202,
    /**
     * RTCP BYE packet.
     */
    BYE = 203,
    /**
     * RTCP APP packet.
     */
    APP = 204,
    /**
     * RTCP Transport Layer Feedback packet.
     */
    RTPFB = 205,
    /**
     * RTCP Payload Specific Feedback packet.
     */
    PSFB = 206,
    /**
     * RTCP Extended Report packet.
     */
    XR = 207
}
/**
 * Base RTCP packet info dump.
 *
 * @category RTCP
 */
export type RtcpPacketDump = PacketDump & {
    packetType: RtcpPacketType;
    count: number;
};
/**
 * Whether the given buffer view could be a valid RTCP packet or not.
 *
 * @category RTCP
 */
export declare function isRtcp(view: DataView): boolean;
/**
 * Get the RTCP packet type.
 *
 * @hidden
 */
export declare function getRtcpPacketType(view: DataView): RtcpPacketType;
/**
 * Read the RTCP header length value and compute its size in bytes (including
 * first octet).
 *
 * @hidden
 */
export declare function getRtcpLength(view: DataView): number;
/**
 * @hidden
 */
export declare function packetTypeToString(packetType: RtcpPacketType): string;
/**
 * RTCP packet. Parent class of all RTCP packets.
 *
 * ```text
 *         0                   1                   2                   3
 *         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * header |V=2|P|    SC   |      PT       |             length            |
 *        +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
 * ```
 *
 * @category RTCP
 *
 * @see
 * - [RFC 3550 section 6.1](https://datatracker.ietf.org/doc/html/rfc3550#section-6.1)
 */
export declare abstract class RtcpPacket extends Packet {
    #private;
    protected constructor(packetType: RtcpPacketType, view?: DataView);
    /**
     * Base RTCP packet dump.
     *
     * @remarks
     * - Read the info dump type of each RTCP packet instead.
     */
    dump(): RtcpPacketDump;
    /**
     * Get the RTCP packet type.
     */
    getPacketType(): RtcpPacketType;
    /**
     * Get the RTCP header count value.
     *
     * @remarks
     * - Some RTCP packets do not use this byte (the second one in the common
     *   RTCP header) for counting chunks or items.
     */
    getCount(): number;
    protected writeCommonHeader(): void;
    /**
     * Set the RTCP header count value.
     *
     * @privateRemarks
     * - This method is not public since users should not manipulate this field
     *   directly.
     * - Also, there is no `count` field in all RTCP packets. For instance, XR
     *   and APP packets do not have it.
     */
    protected setCount(count: number): void;
    /**
     * Serialize base RTCP packet into a new buffer.
     */
    protected serializeBase(buffer?: ArrayBuffer, byteOffset?: number): DataView;
    /**
     * Set the RTCP packet type.
     *
     * @privateRemarks
     * - This method is not public since users should not manipulate this field
     *   directly.
     */
    private setPacketType;
}
//# sourceMappingURL=RtcpPacket.d.ts.map