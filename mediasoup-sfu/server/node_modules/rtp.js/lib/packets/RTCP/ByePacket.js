"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ByePacket_ssrcs, _ByePacket_reason;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ByePacket = void 0;
const RtcpPacket_1 = require("./RtcpPacket");
const helpers_1 = require("../../utils/helpers");
/**
 * RTCP BYE packet.
 *
 * ```text
 *         0                   1                   2                   3
 *         0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 *        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * header |V=2|P|    SC   |   PT=BYE=203  |             length            |
 *        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *        |                           SSRC/CSRC                           |
 *        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *        :                              ...                              :
 *        +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
 * (opt)  |     length    |               reason for leaving            ...
 *        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * ```
 *
 * @category RTCP
 *
 * @see
 * - [RFC 3550 section 6.6](https://datatracker.ietf.org/doc/html/rfc3550#section-6.6)
 */
class ByePacket extends RtcpPacket_1.RtcpPacket {
    /**
     * @param view - If given it will be parsed. Otherwise an empty RTCP BYE
     *   packet will be created.
     *
     * @throws
     * - If given `view` does not contain a valid RTCP BYE packet.
     */
    constructor(view) {
        super(RtcpPacket_1.RtcpPacketType.BYE, view);
        // SSRC/CSRC array.
        _ByePacket_ssrcs.set(this, []);
        // Termination season.
        _ByePacket_reason.set(this, void 0);
        if (!this.view) {
            this.view = new DataView(new ArrayBuffer(RtcpPacket_1.COMMON_HEADER_LENGTH));
            // Write version and packet type.
            this.writeCommonHeader();
            return;
        }
        // Position relative to the DataView byte offset.
        let pos = 0;
        // Move to SSRC/CSRC field(s).
        pos += RtcpPacket_1.COMMON_HEADER_LENGTH;
        let count = this.getCount();
        while (count-- > 0) {
            const ssrc = this.view.getUint32(pos);
            __classPrivateFieldGet(this, _ByePacket_ssrcs, "f").push(ssrc);
            pos += 4;
        }
        // Check if there is reason.
        if (pos + this.padding < this.view.byteLength) {
            const reasonLength = this.view.getUint8(pos);
            const reasonPadding = -(reasonLength + 1) & 3;
            // Move to the reason field.
            pos += 1;
            const reasonView = new DataView(this.view.buffer, this.view.byteOffset + pos, reasonLength);
            __classPrivateFieldSet(this, _ByePacket_reason, (0, helpers_1.dataViewToString)(reasonView), "f");
            pos += reasonLength + reasonPadding;
        }
        pos += this.padding;
        // Ensure that view length and parsed length match.
        if (pos !== this.view.byteLength) {
            throw new RangeError(`parsed length (${pos} bytes) does not match view length (${this.view.byteLength} bytes)`);
        }
    }
    /**
     * Dump RTCP BYE packet info.
     */
    dump() {
        return {
            ...super.dump(),
            ssrcs: this.getSsrcs(),
            reason: this.getReason()
        };
    }
    /**
     * @inheritDoc
     */
    getByteLength() {
        if (!this.needsSerialization()) {
            return this.view.byteLength;
        }
        let packetLength = RtcpPacket_1.COMMON_HEADER_LENGTH + (__classPrivateFieldGet(this, _ByePacket_ssrcs, "f").length * 4);
        if (__classPrivateFieldGet(this, _ByePacket_reason, "f")) {
            const reasonLength = (0, helpers_1.getStringByteLength)(__classPrivateFieldGet(this, _ByePacket_reason, "f"));
            const reasonPadding = -(reasonLength + 1) & 3;
            packetLength += 1 + reasonLength + reasonPadding;
        }
        packetLength += this.padding;
        return packetLength;
    }
    /**
     * @inheritDoc
     */
    serialize(buffer, byteOffset) {
        const view = this.serializeBase(buffer, byteOffset);
        // Position relative to the DataView byte offset.
        let pos = 0;
        // Move to SSRCs/CSRCs.
        pos += RtcpPacket_1.COMMON_HEADER_LENGTH;
        // Write SSRCs/CSRCs.
        for (const ssrc of __classPrivateFieldGet(this, _ByePacket_ssrcs, "f")) {
            view.setUint32(pos, ssrc);
            pos += 4;
        }
        if (__classPrivateFieldGet(this, _ByePacket_reason, "f")) {
            const reasonUint8Array = (0, helpers_1.stringToUint8Array)(__classPrivateFieldGet(this, _ByePacket_reason, "f"));
            const reasonLength = reasonUint8Array.byteLength;
            const reasonPadding = -(reasonLength + 1) & 3;
            const uint8Array = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
            // Write reason length.
            view.setUint8(pos, reasonLength);
            // Move to reason field.
            pos += 1;
            // Copy reason.
            uint8Array.set(reasonUint8Array, pos);
            // Move to padding.
            pos += reasonLength + reasonPadding;
        }
        pos += this.padding;
        // Assert that current position is equal than new buffer length.
        if (pos !== view.byteLength) {
            throw new RangeError(`filled length (${pos} bytes) is different than the available buffer size (${view.byteLength} bytes)`);
        }
        // Update DataView.
        this.view = view;
        this.setSerializationNeeded(false);
    }
    /**
     * @inheritDoc
     */
    clone(buffer, byteOffset, serializationBuffer, serializationByteOffset) {
        const view = this.cloneInternal(buffer, byteOffset, serializationBuffer, serializationByteOffset);
        return new ByePacket(view);
    }
    /**
     * Get SSRC values.
     */
    getSsrcs() {
        return Array.from(__classPrivateFieldGet(this, _ByePacket_ssrcs, "f"));
    }
    /**
     * Set SSRC values.
     *
     * @remarks
     * - Serialization is needed after calling this method.
     */
    setSsrcs(ssrcs) {
        __classPrivateFieldSet(this, _ByePacket_ssrcs, Array.from(ssrcs), "f");
        // Update RTCP count.
        this.setCount(__classPrivateFieldGet(this, _ByePacket_ssrcs, "f").length);
        this.setSerializationNeeded(true);
    }
    /**
     * Add SSRC value.
     *
     * @remarks
     * - Serialization is needed after calling this method.
     */
    addSsrc(ssrc) {
        __classPrivateFieldGet(this, _ByePacket_ssrcs, "f").push(ssrc);
        // Update RTCP count.
        this.setCount(__classPrivateFieldGet(this, _ByePacket_ssrcs, "f").length);
        this.setSerializationNeeded(true);
    }
    /**
     * Get reason.
     */
    getReason() {
        return __classPrivateFieldGet(this, _ByePacket_reason, "f");
    }
    /**
     * Set reason.
     */
    setReason(reason) {
        __classPrivateFieldSet(this, _ByePacket_reason, reason, "f");
        this.setSerializationNeeded(true);
    }
}
exports.ByePacket = ByePacket;
_ByePacket_ssrcs = new WeakMap(), _ByePacket_reason = new WeakMap();
