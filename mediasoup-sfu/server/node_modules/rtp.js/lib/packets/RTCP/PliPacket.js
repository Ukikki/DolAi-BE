"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PliPacket = void 0;
const RtcpPacket_1 = require("./RtcpPacket");
const FeedbackPacket_1 = require("./FeedbackPacket");
/**
 * RTCP PLI packet (RTCP Payload Specific Feedback).
 *
 * ```text
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |V=2|P|  FMT=1  |  PT=PSFB=206  |          length=2             |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  SSRC of packet sender                        |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                  SSRC of media source                         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * ```
 *
 * @category RTCP
 *
 * @see
 * - [RFC 4585 section 6.3.1](https://datatracker.ietf.org/doc/html/rfc4585#section-6.3.1)
 */
class PliPacket extends FeedbackPacket_1.FeedbackPacket {
    /**
     * @param view - If given it will be parsed. Otherwise an empty RTCP PLI
     *   packet will be created.
     *
     * @throws
     * - If given `view` does not contain a valid RTCP PLI packet.
     */
    constructor(view) {
        super(RtcpPacket_1.RtcpPacketType.PSFB, FeedbackPacket_1.PsFeedbackMessageType.PLI, view);
        if (!this.view) {
            this.view = new DataView(new ArrayBuffer(FeedbackPacket_1.FIXED_HEADER_LENGTH));
            // Write version, packet type and feedback message type.
            this.writeFixedHeader();
            return;
        }
        // Position relative to the DataView byte offset.
        let pos = 0;
        // Move to padding.
        pos += FeedbackPacket_1.FIXED_HEADER_LENGTH;
        pos += this.padding;
        // Ensure that view length and parsed length match.
        if (pos !== this.view.byteLength) {
            throw new RangeError(`parsed length (${pos} bytes) does not match view length (${this.view.byteLength} bytes)`);
        }
    }
    /**
     * Dump RTCP PLI packet info.
     */
    dump() {
        return super.dump();
    }
    /**
     * @inheritDoc
     */
    getByteLength() {
        if (!this.needsSerialization()) {
            return this.view.byteLength;
        }
        const packetLength = FeedbackPacket_1.FIXED_HEADER_LENGTH + this.padding;
        return packetLength;
    }
    /**
     * @inheritDoc
     */
    serialize(buffer, byteOffset) {
        const view = this.serializeBase(buffer, byteOffset);
        // Nothing else to do.
        // Update DataView.
        this.view = view;
        this.setSerializationNeeded(false);
    }
    /**
     * @inheritDoc
     */
    clone(buffer, byteOffset, serializationBuffer, serializationByteOffset) {
        const view = this.cloneInternal(buffer, byteOffset, serializationBuffer, serializationByteOffset);
        return new PliPacket(view);
    }
}
exports.PliPacket = PliPacket;
