"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _DrleExtendedReport_chunks;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DrleExtendedReport = void 0;
const ExtendedReport_1 = require("./ExtendedReport");
const helpers_1 = require("../../../utils/helpers");
const bitOps_1 = require("../../../utils/bitOps");
// Common header + SSRC of source + begin seq + end seq.
const DRLE_EXTENDED_REPORT_MIN_LENGTH = ExtendedReport_1.COMMON_HEADER_LENGTH + 8;
/**
 * Duplicate RLE Extended Report.
 *
 * ```text
 *  0                   1                   2                   3
 *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |     BT=2      | rsvd. |   T   |         block length          |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                        SSRC of source                         |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |          begin_seq            |             end_seq           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |          chunk 1              |             chunk 2           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * :                              ...                              :
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |          chunk n-1            |             chunk n           |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * ```
 *
 * @category RTCP Extended Reports
 *
 * @see
 * - [RFC 3611 section 4.2](https://datatracker.ietf.org/doc/html/rfc3611#section-4.2)
 */
class DrleExtendedReport extends ExtendedReport_1.ExtendedReport {
    /**
     * @param view - If given it will be parsed. Otherwise an empty Duplicate RLE
     *   Extended Report will be created.
     */
    constructor(view) {
        super(ExtendedReport_1.ExtendedReportType.DRLE, view);
        // Chunks (2 bytes numbers, unparsed).
        _DrleExtendedReport_chunks.set(this, []);
        if (!this.view) {
            this.view = new DataView(new ArrayBuffer(DRLE_EXTENDED_REPORT_MIN_LENGTH));
            // Write report type.
            this.writeCommonHeader();
            return;
        }
        if (this.view.byteLength < DRLE_EXTENDED_REPORT_MIN_LENGTH) {
            throw new TypeError('wrong byte length for a Duplicate RLE Extended Report');
        }
        // Position relative to the DataView byte offset.
        let pos = 0;
        // Move to chunks.
        pos += DRLE_EXTENDED_REPORT_MIN_LENGTH;
        while (pos < this.view.byteLength) {
            const chunk = this.view.getUint16(pos);
            if (chunk === 0) {
                break;
            }
            __classPrivateFieldGet(this, _DrleExtendedReport_chunks, "f").push(chunk);
            pos += 2;
        }
    }
    /**
     * Dump Duplicate RLE Extended Report info.
     */
    dump() {
        return {
            ...super.dump(),
            thinning: this.getThinning(),
            ssrc: this.getSsrc(),
            beginSeq: this.getBeginSeq(),
            endSeq: this.getEndSeq(),
            chunks: this.getChunks()
        };
    }
    /**
     * @inheritDoc
     */
    getByteLength() {
        if (!this.needsSerialization()) {
            return this.view.byteLength;
        }
        // Common header + SSRC + begin seq + end seq.
        let reportLength = DRLE_EXTENDED_REPORT_MIN_LENGTH;
        // Add chunks.
        reportLength += __classPrivateFieldGet(this, _DrleExtendedReport_chunks, "f").length * 2;
        // The list of chunks must terminate in terminating null chunks, which
        // basically means padding them to 4 bytes.
        reportLength = (0, helpers_1.padTo4Bytes)(reportLength);
        return reportLength;
    }
    /**
     * @inheritDoc
     */
    serialize(buffer, byteOffset) {
        const view = this.serializeBase(buffer, byteOffset);
        const uint8Array = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
        // Position relative to the DataView byte offset.
        let pos = 0;
        // Move to the fixed header fields after the common header.
        pos += ExtendedReport_1.COMMON_HEADER_LENGTH;
        // Copy the rest of the fixed fields into the new buffer.
        uint8Array.set(new Uint8Array(this.view.buffer, this.view.byteOffset + pos, DRLE_EXTENDED_REPORT_MIN_LENGTH - ExtendedReport_1.COMMON_HEADER_LENGTH), pos);
        // Move to chunks.
        pos += DRLE_EXTENDED_REPORT_MIN_LENGTH - ExtendedReport_1.COMMON_HEADER_LENGTH;
        // Copy chunks.
        for (const chunk of __classPrivateFieldGet(this, _DrleExtendedReport_chunks, "f")) {
            view.setUint16(pos, chunk);
            pos += 2;
        }
        // NOTE: Must pad the content to 4 bytes.
        pos = (0, helpers_1.padTo4Bytes)(pos);
        if (pos !== view.byteLength) {
            throw new RangeError(`filled length (${pos} bytes) does not match the available buffer size (${view.byteLength} bytes)`);
        }
        // Update DataView.
        this.view = view;
        this.setSerializationNeeded(false);
    }
    /**
     * @inheritDoc
     */
    clone(buffer, byteOffset, serializationBuffer, serializationByteOffset) {
        const view = this.cloneInternal(buffer, byteOffset, serializationBuffer, serializationByteOffset);
        return new DrleExtendedReport(view);
    }
    /**
     * Get thinning.
     */
    getThinning() {
        return (0, bitOps_1.readBitsInDataView)({ view: this.view, pos: 1, mask: 0x0F });
    }
    /**
     * Set thinning.
     */
    setThinning(thinning) {
        (0, bitOps_1.writeBitsInDataView)({ view: this.view, pos: 1, mask: 0x0F, value: thinning });
        this.setSerializationNeeded(true);
    }
    /**
     * Get SSRC of source.
     */
    getSsrc() {
        return this.view.getUint32(4);
    }
    /**
     * Set SSRC of source.
     */
    setSsrc(ssrc) {
        this.view.setUint32(4, ssrc);
        this.setSerializationNeeded(true);
    }
    /**
     * Get begin sequence number.
     */
    getBeginSeq() {
        return this.view.getUint16(8);
    }
    /**
     * Set begin sequence number.
     */
    setBeginSeq(seq) {
        this.view.setUint16(8, seq);
        this.setSerializationNeeded(true);
    }
    /**
     * Get end sequence number.
     */
    getEndSeq() {
        return this.view.getUint16(10);
    }
    /**
     * Set end sequence number.
     */
    setEndSeq(seq) {
        this.view.setUint16(10, seq);
        this.setSerializationNeeded(true);
    }
    /**
     * Get chunks.
     *
     * @remarks
     * - Chunks are given as a list of 2 byte integers.
     * - Use {@link parseExtendedReportChunk} to parse them.
     */
    getChunks() {
        return Array.from(__classPrivateFieldGet(this, _DrleExtendedReport_chunks, "f"));
    }
    /**
     * Set chunks.
     *
     * @remarks
     * - Chunks must be given as a list of 2 byte integers.
     * - Use {@link createExtendedReportRunLengthChunk} or
     *   {@link createExtendedReportBitVectorChunk} to create them.
     */
    setChunks(chunks) {
        __classPrivateFieldSet(this, _DrleExtendedReport_chunks, Array.from(chunks), "f");
        this.setSerializationNeeded(true);
    }
    /**
     * Add chunk.
     *
     * @remarks
     * - Chunk must be given as 2 byte integer.
     * - Use {@link createExtendedReportRunLengthChunk} or
     *   {@link createExtendedReportBitVectorChunk} to create it.
     * - Given chunk cannot be a terminating null chunk (0 number).
     */
    addChunk(chunk) {
        if (chunk === 0) {
            throw new TypeError('cannot add terminating null chunks');
        }
        __classPrivateFieldGet(this, _DrleExtendedReport_chunks, "f").push(chunk);
        this.setSerializationNeeded(true);
    }
}
exports.DrleExtendedReport = DrleExtendedReport;
_DrleExtendedReport_chunks = new WeakMap();
