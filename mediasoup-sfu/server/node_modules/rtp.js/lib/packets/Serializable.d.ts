/**
 * Serializable info dump.
 */
export type SerializableDump = {
    byteLength: number;
};
/**
 * Class holding a serializable buffer view. All RTP and RTCP packets inherit
 * from this class, and also items in some RTCP packets.
 */
export declare abstract class Serializable {
    #private;
    protected view: DataView;
    protected constructor(view?: DataView);
    /**
     * Serializable dump.
     */
    dump(): SerializableDump;
    /**
     * Get a buffer view containing the serialized content of the packet or item.
     *
     * @param serializationBuffer - Buffer in which the content will be serialized
     *   in case serialization is needed. If not given, a new one will internally
     *   allocated.
     * @param serializationByteOffset - Byte offset of the given `serializationBuffer`
     *   where serialization (if needed) will start.
     *
     * @remarks
     * - The internal buffer is serialized if needed (to apply pending
     * 	 modifications) by internally calling {@link serialize}.
     *
     * @throws
     * - If buffer serialization is needed and it fails due to invalid
     *   content.
     */
    getView(serializationBuffer?: ArrayBuffer, serializationByteOffset?: number): DataView;
    /**
     * Computes total length of the content (in bytes) including padding if any.
     *
     * @remarks
     * - This methods computes the effective byte length of the content as if it
     *   was serialized at this moment, no matter modifications have been done
     *   before.
     */
    abstract getByteLength(): number;
    /**
     * Whether serialization is needed, meaning that the current buffer view
     * doesn't represent the current content of the packet or item (due to
     * modifications not applied yet). Calling {@link serialize} or {@link getView}
     * will serialize the packet or the item.
     */
    needsSerialization(): boolean;
    /**
     * Apply pending changes and serialize the content of the packet or item into
     * a new buffer.
     *
     * @param buffer - Buffer in which the content will be serialized. If not
     *   given, a new one will internally allocated.
     * @param byteOffset - Byte offset of the given `buffer` where serialization
     *   will start.
     *
     * @remarks
     * - In most cases there is no need to use this method since many setter
     *   methods apply changes within the current buffer. To be sure, check
     *   {@link needsSerialization} before.
     *
     * @throws
     * - If serialization fails due to invalid content previously added.
     * - If given `buffer` doesn't have space enough to serialize the content.
     */
    abstract serialize(buffer?: ArrayBuffer, byteOffset?: number): void;
    /**
     * Clone the packet or item. The cloned instance does not share any memory
     * with the original one. The cloned instance is a new class instance
     * referencing a different buffer.
     *
     * @param buffer - Buffer in which the content will be cloned. If not given, a
     *   new one will internally allocated.
     * @param byteOffset - Byte offset of the given `buffer` where clonation will
     *   start.
     * @param serializationBuffer - Buffer in which the content will be serialized
     *   in case serialization is needed. If not given, a new one will internally
     *   allocated.
     * @param serializationByteOffset - Byte offset of the given
     *   `serializationBuffer` where serialization (if needed) will start.
     *
     * @remarks
     * - The buffer is serialized if needed (to apply pending modifications) by
     *   internally calling {@link serialize}.
     *
     * @throws
     * - If serialization is needed and it fails.
     * - If given `buffer` doesn't have space enough to clone the content.
     * - If given `serializationBuffer` doesn't have space enough to serialize
     *   the content.
     */
    abstract clone(buffer?: ArrayBuffer, byteOffset?: number, serializationBuffer?: ArrayBuffer, serializationByteOffset?: number): Serializable;
    protected setSerializationNeeded(flag: boolean): void;
    /**
     * This method returns a buffer (plus byte offset) for the child to serialize.
     * If a buffer (and optionally a byte offset) is given, this method will verify
     * whether the serialized content can fit into it and will throw otherwise.
     */
    protected getSerializationBuffer(buffer?: ArrayBuffer, byteOffset?: number): {
        buffer: ArrayBuffer;
        byteOffset: number;
        byteLength: number;
    };
    protected cloneInternal(buffer?: ArrayBuffer, byteOffset?: number, serializationBuffer?: ArrayBuffer, serializationByteOffset?: number): DataView;
}
//# sourceMappingURL=Serializable.d.ts.map