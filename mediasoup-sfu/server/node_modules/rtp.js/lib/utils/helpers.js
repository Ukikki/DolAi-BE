"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStringByteLength = exports.stringToUint8Array = exports.stringToArrayBuffer = exports.stringToDataView = exports.arrayBufferToString = exports.dataViewToString = exports.numberToDataView = exports.numericArrayToDataView = exports.nodeBufferToArrayBuffer = exports.nodeBufferToDataView = exports.areDataViewsEqual = exports.padTo4Bytes = exports.assertUnreachable = exports.clone = void 0;
const Logger_1 = require("../Logger");
const logger = new Logger_1.Logger('utils/helpers');
/**
 * Clones the given object/array/Buffer/etc.
 *
 * @category Utils
 * @hidden
 */
function clone(data) {
    if (data instanceof ArrayBuffer) {
        return data.slice(0);
    }
    else if (data instanceof DataView) {
        return new DataView(data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength));
    }
    else if (data === undefined) {
        return undefined;
    }
    else if (Number.isNaN(data)) {
        return NaN;
    }
    else if (typeof structuredClone === 'function') {
        // Available in Node >= 18.
        return structuredClone(data);
    }
    else {
        return JSON.parse(JSON.stringify(data));
    }
}
exports.clone = clone;
/**
 * TypeScript utility to assert that no `case X` is missing in a `switch()`
 * block.
 *
 * @category Utils
 * @hidden
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function assertUnreachable(_x) {
    throw new Error(`we should not get here: ${_x}`);
}
exports.assertUnreachable = assertUnreachable;
/**
 * Returns the given size padded to 4 bytes.
 *
 * @category Utils
 */
function padTo4Bytes(size) {
    // If size is not multiple of 32 bits then pad it.
    if (size & 0x03) {
        return (size & 0xFFFC) + 4;
    }
    else {
        return size;
    }
}
exports.padTo4Bytes = padTo4Bytes;
/**
 * Whether two DataViews contain the same data.
 *
 * @category Utils
 * @hidden
 */
function areDataViewsEqual(view1, view2) {
    if (view1 === view2) {
        logger.debug('areDataViewsEqual() | view1 and view2 are the same DataView instance');
        return true;
    }
    if (view1.byteLength !== view2.byteLength) {
        if (logger.debug.enabled) {
            logger.debug(`areDataViewsEqual() | different byte length [view1.byteLength:${view1.byteLength}, view2.byteLength:${view2.byteLength}]`);
            logger.debug('areDataViewsEqual() | view1:', view1);
            logger.debug('areDataViewsEqual() | view2:', view2);
        }
        return false;
    }
    let i = 0;
    while (i < view1.byteLength) {
        if (view1.getUint8(i) !== view2.getUint8(i)) {
            if (logger.debug.enabled) {
                logger.debug(`areDataViewsEqual() | different byte [idx:${i}, view1:${view1.getUint8(i).toString(16)}, view2:${view2.getUint8(i).toString(16)}]`);
                logger.debug('areDataViewsEqual() | view1:', view1);
                logger.debug('areDataViewsEqual() | view2:', view2);
            }
            return false;
        }
        i++;
    }
    return true;
}
exports.areDataViewsEqual = areDataViewsEqual;
/**
 * Convert Node.js Buffer to DataView using the same underlying ArrayBuffer.
 *
 * @category Utils
 * @remarks
 * - Just for Node.js.
 */
function nodeBufferToDataView(buffer) {
    return new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
}
exports.nodeBufferToDataView = nodeBufferToDataView;
/**
 * Convert Node.js Buffer to a new allocated ArrayBuffer.
 *
 * @category Utils
 * @remarks
 * - Just for Node.js.
 */
function nodeBufferToArrayBuffer(buffer) {
    return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
}
exports.nodeBufferToArrayBuffer = nodeBufferToArrayBuffer;
/**
 * Convert array of integers to DataView.
 *
 * @category Utils
 */
function numericArrayToDataView(array) {
    return new DataView((new Uint8Array(array)).buffer);
}
exports.numericArrayToDataView = numericArrayToDataView;
/**
 * Convert number to DataView.
 *
 * @category Utils
 */
function numberToDataView(number) {
    const array = [];
    array.unshift(number & 255);
    while (number >= 256) {
        number = number >>> 8;
        array.unshift(number & 255);
    }
    const uint8Array = new Uint8Array(array);
    return new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
}
exports.numberToDataView = numberToDataView;
/**
 * Convert DataView to string.
 *
 * @category Utils
 */
function dataViewToString(view) {
    const decoder = new TextDecoder();
    return decoder.decode(view);
}
exports.dataViewToString = dataViewToString;
/**
 * Convert ArrayBuffer to string.
 *
 * @category Utils
 */
function arrayBufferToString(buffer) {
    const decoder = new TextDecoder();
    return decoder.decode(buffer);
}
exports.arrayBufferToString = arrayBufferToString;
/**
 * Convert string to DataView.
 *
 * @category Utils
 */
function stringToDataView(string) {
    const encoder = new TextEncoder();
    const uint8Array = encoder.encode(string);
    return new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
}
exports.stringToDataView = stringToDataView;
/**
 * Convert string to ArrayBuffer.
 *
 * @category Utils
 * @hidden
 */
function stringToArrayBuffer(string) {
    const encoder = new TextEncoder();
    return encoder.encode(string).buffer;
}
exports.stringToArrayBuffer = stringToArrayBuffer;
/**
 * Convert string to Uint8Array.
 *
 * @category Utils
 * @hidden
 */
function stringToUint8Array(string) {
    const encoder = new TextEncoder();
    const uint8Array = encoder.encode(string);
    return new Uint8Array(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);
}
exports.stringToUint8Array = stringToUint8Array;
/**
 * Get the byte length of a string.
 *
 * @category Utils
 */
function getStringByteLength(string) {
    const encoder = new TextEncoder();
    const uint8Array = encoder.encode(string);
    return uint8Array.byteLength;
}
exports.getStringByteLength = getStringByteLength;
