"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeBitsInDataView = exports.readBitsInDataView = exports.toggleBitInDataView = exports.writeBitInDataView = exports.readBitInDataView = exports.writeBits = exports.readBits = exports.toggleBit = exports.writeBit = exports.readBit = void 0;
/**
 * Read the value of `bit` position` of `value`.
 *
 * @category Utils
 * @hidden
 */
function readBit({ value, bit }) {
    return (value & (1 << bit)) ? true : false;
}
exports.readBit = readBit;
/**
 * Write `flag` in `bit` position` of `value` and return updated value.
 *
 * @category Utils
 * @hidden
 */
function writeBit({ value, bit, flag }) {
    if (flag) {
        return value | (1 << bit);
    }
    else {
        return value & ~(1 << bit);
    }
}
exports.writeBit = writeBit;
/**
 * Toggle value of `bit` position` of `value` and return update value.
 *
 * @category Utils
 * @hidden
 */
function toggleBit({ value, bit }) {
    return value ^ (1 << bit);
}
exports.toggleBit = toggleBit;
/**
 * Read the value of the enabled bits of `mask` of byte `byte`.
 *
 * @category Utils
 * @hidden
 */
function readBits({ byte, mask }) {
    const bitsToShift = getFirstEnabledBitInMask(mask);
    return (byte & mask) >> bitsToShift;
}
exports.readBits = readBits;
/**
 * Write `value` in the enabled bits of `mask` of byte `byte` and return
 * updated value.
 *
 * @category Utils
 * @hidden
 */
function writeBits({ byte, mask, value }) {
    const inverseMask = mask ^ 0b11111111;
    const bitsToShift = getFirstEnabledBitInMask(mask);
    return (byte & inverseMask) | ((value << bitsToShift) & mask);
}
exports.writeBits = writeBits;
/**
 * Read the value of `bit` position` of byte `pos` in `view`.
 *
 * @category Utils
 * @hidden
 */
function readBitInDataView({ view, pos, bit }) {
    return readBit({ value: view.getUint8(pos), bit });
}
exports.readBitInDataView = readBitInDataView;
/**
 * Write `flag` in `bit` position` of byte `pos` in `view`.
 *
 * @category Utils
 * @hidden
 */
function writeBitInDataView({ view, pos, bit, flag }) {
    view.setUint8(pos, writeBit({ value: view.getUint8(pos), bit, flag }));
}
exports.writeBitInDataView = writeBitInDataView;
/**
 * Toggle value of `bit` position` of byte `pos` in `view`.
 *
 * @category Utils
 * @hidden
 */
function toggleBitInDataView({ view, pos, bit }) {
    view.setUint8(pos, toggleBit({ value: view.getUint8(pos), bit }));
}
exports.toggleBitInDataView = toggleBitInDataView;
/**
 * Read the value of the enabled bits of `mask` of byte `pos` in `view`.
 *
 * @category Utils
 * @hidden
 */
function readBitsInDataView({ view, pos, mask }) {
    return readBits({ byte: view.getUint8(pos), mask });
}
exports.readBitsInDataView = readBitsInDataView;
/**
 * Write `value` in the enabled bits of `mask` of byte `pos` in `view`.
 *
 * @category Utils
 * @hidden
 */
function writeBitsInDataView({ view, pos, mask, value }) {
    view.setUint8(pos, writeBits({ byte: view.getUint8(pos), mask, value }));
}
exports.writeBitsInDataView = writeBitsInDataView;
function getFirstEnabledBitInMask(mask) {
    if (mask === 0 || mask > 0b11111111) {
        throw new TypeError(`invalid byte mask 0b${mask.toString(2)}`);
    }
    for (let bit = 0; bit < 8; ++bit) {
        if (mask & (1 << bit)) {
            return bit;
        }
    }
    // This should not happen unless given mask is 0.
    throw new Error(`no enabled bit found in byte mask 0b${mask.toString(2)}`);
}
