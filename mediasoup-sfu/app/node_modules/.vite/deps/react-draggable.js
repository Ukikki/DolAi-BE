import {
  require_react_dom
} from "./chunk-CB7Y6BLN.js";
import {
  require_react
} from "./chunk-I2KYBY5W.js";
import {
  __commonJS
} from "./chunk-C5Q7R5PP.js";

// node_modules/react-draggable/dist/react-draggable.js
var require_react_draggable = __commonJS({
  "node_modules/react-draggable/dist/react-draggable.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory(require_react_dom(), require_react()) : typeof define === "function" && define.amd ? define(["react-dom", "react"], factory) : global.ReactDraggable = factory(global.ReactDOM, global.React);
    })(exports, function(ReactDOM, React) {
      "use strict";
      ReactDOM = ReactDOM && ReactDOM.hasOwnProperty("default") ? ReactDOM["default"] : ReactDOM;
      React = React && React.hasOwnProperty("default") ? React["default"] : React;
      function createCommonjsModule(fn, module2) {
        return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
      }
      function makeEmptyFunction(arg) {
        return function() {
          return arg;
        };
      }
      var emptyFunction = function emptyFunction2() {
      };
      emptyFunction.thatReturns = makeEmptyFunction;
      emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
      emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
      emptyFunction.thatReturnsNull = makeEmptyFunction(null);
      emptyFunction.thatReturnsThis = function() {
        return this;
      };
      emptyFunction.thatReturnsArgument = function(arg) {
        return arg;
      };
      var emptyFunction_1 = emptyFunction;
      var validateFormat = function validateFormat2(format) {
      };
      {
        validateFormat = function validateFormat2(format) {
          if (format === void 0) {
            throw new Error("invariant requires an error message argument");
          }
        };
      }
      function invariant(condition, format, a, b, c, d, e, f) {
        validateFormat(format);
        if (!condition) {
          var error;
          if (format === void 0) {
            error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
          } else {
            var args = [a, b, c, d, e, f];
            var argIndex = 0;
            error = new Error(format.replace(/%s/g, function() {
              return args[argIndex++];
            }));
            error.name = "Invariant Violation";
          }
          error.framesToPop = 1;
          throw error;
        }
      }
      var invariant_1 = invariant;
      var warning = emptyFunction_1;
      {
        var printWarning = function printWarning2(format) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          var argIndex = 0;
          var message = "Warning: " + format.replace(/%s/g, function() {
            return args[argIndex++];
          });
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x) {
          }
        };
        warning = function warning2(condition, format) {
          if (format === void 0) {
            throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
          }
          if (format.indexOf("Failed Composite propType: ") === 0) {
            return;
          }
          if (!condition) {
            for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              args[_key2 - 2] = arguments[_key2];
            }
            printWarning.apply(void 0, [format].concat(args));
          }
        };
      }
      var warning_1 = warning;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      var ReactPropTypesSecret_1 = ReactPropTypesSecret;
      {
        var invariant$1 = invariant_1;
        var warning$1 = warning_1;
        var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
        var loggedTypeFailures = {};
      }
      function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
        {
          for (var typeSpecName in typeSpecs) {
            if (typeSpecs.hasOwnProperty(typeSpecName)) {
              var error;
              try {
                invariant$1(typeof typeSpecs[typeSpecName] === "function", "%s: %s type `%s` is invalid; it must be a function, usually from the `prop-types` package, but received `%s`.", componentName || "React class", location, typeSpecName, typeof typeSpecs[typeSpecName]);
                error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
              } catch (ex) {
                error = ex;
              }
              warning$1(!error || error instanceof Error, "%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error);
              if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                loggedTypeFailures[error.message] = true;
                var stack = getStack ? getStack() : "";
                warning$1(false, "Failed %s type: %s%s", location, error.message, stack != null ? stack : "");
              }
            }
          }
        }
      }
      var checkPropTypes_1 = checkPropTypes;
      var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var ANONYMOUS = "<<anonymous>>";
        var ReactPropTypes = {
          array: createPrimitiveTypeChecker("array"),
          bool: createPrimitiveTypeChecker("boolean"),
          func: createPrimitiveTypeChecker("function"),
          number: createPrimitiveTypeChecker("number"),
          object: createPrimitiveTypeChecker("object"),
          string: createPrimitiveTypeChecker("string"),
          symbol: createPrimitiveTypeChecker("symbol"),
          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker
        };
        function is(x, y) {
          if (x === y) {
            return x !== 0 || 1 / x === 1 / y;
          } else {
            return x !== x && y !== y;
          }
        }
        function PropTypeError(message) {
          this.message = message;
          this.stack = "";
        }
        PropTypeError.prototype = Error.prototype;
        function createChainableTypeChecker(validate) {
          {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret_1) {
              if (throwOnDirectAccess) {
                invariant_1(
                  false,
                  "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                );
              } else if (typeof console !== "undefined") {
                var cacheKey = componentName + ":" + propName;
                if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                manualPropTypeWarningCount < 3) {
                  warning_1(
                    false,
                    "You are manually calling a React.PropTypes validation function for the `%s` prop on `%s`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.",
                    propFullName,
                    componentName
                  );
                  manualPropTypeCallCache[cacheKey] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                }
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
              }
              return null;
            } else {
              return validate(props, propName, componentName, location, propFullName);
            }
          }
          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
          function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
              var preciseType = getPreciseType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunction_1.thatReturnsNull);
        }
        function createArrayOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i = 0; i < propValue.length; i++) {
              var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret_1);
              if (error instanceof Error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createInstanceTypeChecker(expectedClass) {
          function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              var expectedClassName = expectedClass.name || ANONYMOUS;
              var actualClassName = getClassName(props[propName]);
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            warning_1(false, "Invalid argument supplied to oneOf, expected an instance of array.");
            return emptyFunction_1.thatReturnsNull;
          }
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for (var i = 0; i < expectedValues.length; i++) {
              if (is(propValue, expectedValues[i])) {
                return null;
              }
            }
            var valuesString = JSON.stringify(expectedValues);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + propValue + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createObjectOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
              if (propValue.hasOwnProperty(key)) {
                var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret_1);
                if (error instanceof Error) {
                  return error;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            warning_1(false, "Invalid argument supplied to oneOfType, expected an instance of array.");
            return emptyFunction_1.thatReturnsNull;
          }
          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== "function") {
              warning_1(
                false,
                "Invalid argument supplied to oneOfType. Expected an array of check functions, but received %s at index %s.",
                getPostfixForTypeWarning(checker),
                i
              );
              return emptyFunction_1.thatReturnsNull;
            }
          }
          function validate(props, propName, componentName, location, propFullName) {
            for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
              var checker2 = arrayOfTypeCheckers[i2];
              if (checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
                return null;
              }
            }
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`."));
          }
          return createChainableTypeChecker(validate);
        }
        function createNodeChecker() {
          function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
              var checker = shapeTypes[key];
              if (!checker) {
                continue;
              }
              var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret_1);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createStrictShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            var allKeys = objectAssign({}, props[propName], shapeTypes);
            for (var key in allKeys) {
              var checker = shapeTypes[key];
              if (!checker) {
                return new PropTypeError(
                  "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                );
              }
              var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret_1);
              if (error) {
                return error;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function isNode(propValue) {
          switch (typeof propValue) {
            case "number":
            case "string":
            case "undefined":
              return true;
            case "boolean":
              return !propValue;
            case "object":
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement(propValue)) {
                return true;
              }
              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                var iterator = iteratorFn.call(propValue);
                var step;
                if (iteratorFn !== propValue.entries) {
                  while (!(step = iterator.next()).done) {
                    if (!isNode(step.value)) {
                      return false;
                    }
                  }
                } else {
                  while (!(step = iterator.next()).done) {
                    var entry = step.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }
              return true;
            default:
              return false;
          }
        }
        function isSymbol(propType, propValue) {
          if (propType === "symbol") {
            return true;
          }
          if (propValue["@@toStringTag"] === "Symbol") {
            return true;
          }
          if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
          }
          return false;
        }
        function getPropType(propValue) {
          var propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return "array";
          }
          if (propValue instanceof RegExp) {
            return "object";
          }
          if (isSymbol(propType, propValue)) {
            return "symbol";
          }
          return propType;
        }
        function getPreciseType(propValue) {
          if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
          }
          var propType = getPropType(propValue);
          if (propType === "object") {
            if (propValue instanceof Date) {
              return "date";
            } else if (propValue instanceof RegExp) {
              return "regexp";
            }
          }
          return propType;
        }
        function getPostfixForTypeWarning(value) {
          var type = getPreciseType(value);
          switch (type) {
            case "array":
            case "object":
              return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
              return "a " + type;
            default:
              return type;
          }
        }
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }
        ReactPropTypes.checkPropTypes = checkPropTypes_1;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
      var propTypes = createCommonjsModule(function(module2) {
        {
          var REACT_ELEMENT_TYPE = typeof Symbol === "function" && Symbol.for && Symbol.for("react.element") || 60103;
          var isValidElement = function(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          };
          var throwOnDirectAccess = true;
          module2.exports = factoryWithTypeCheckers(isValidElement, throwOnDirectAccess);
        }
      });
      var classnames = createCommonjsModule(function(module2) {
        (function() {
          var hasOwn = {}.hasOwnProperty;
          function classNames() {
            var classes = [];
            for (var i = 0; i < arguments.length; i++) {
              var arg = arguments[i];
              if (!arg) continue;
              var argType = typeof arg;
              if (argType === "string" || argType === "number") {
                classes.push(arg);
              } else if (Array.isArray(arg)) {
                classes.push(classNames.apply(null, arg));
              } else if (argType === "object") {
                for (var key in arg) {
                  if (hasOwn.call(arg, key) && arg[key]) {
                    classes.push(key);
                  }
                }
              }
            }
            return classes.join(" ");
          }
          if (module2.exports) {
            module2.exports = classNames;
          } else if (false) {
            (void 0)("classnames", [], function() {
              return classNames;
            });
          } else {
            window.classNames = classNames;
          }
        })();
      });
      function findInArray(array, callback) {
        for (var i = 0, length = array.length; i < length; i++) {
          if (callback.apply(callback, [array[i], i, array])) return array[i];
        }
      }
      function isFunction(func) {
        return typeof func === "function" || Object.prototype.toString.call(func) === "[object Function]";
      }
      function isNum(num) {
        return typeof num === "number" && !isNaN(num);
      }
      function int(a) {
        return parseInt(a, 10);
      }
      function dontSetMe(props, propName, componentName) {
        if (props[propName]) {
          return new Error("Invalid prop " + propName + " passed to " + componentName + " - do not set this, set it on the child.");
        }
      }
      var prefixes = ["Moz", "Webkit", "O", "ms"];
      function getPrefix() {
        var prop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
        if (typeof window === "undefined" || typeof window.document === "undefined") return "";
        var style = window.document.documentElement.style;
        if (prop in style) return "";
        for (var i = 0; i < prefixes.length; i++) {
          if (browserPrefixToKey(prop, prefixes[i]) in style) return prefixes[i];
        }
        return "";
      }
      function browserPrefixToKey(prop, prefix) {
        return prefix ? "" + prefix + kebabToTitleCase(prop) : prop;
      }
      function kebabToTitleCase(str) {
        var out = "";
        var shouldCapitalize = true;
        for (var i = 0; i < str.length; i++) {
          if (shouldCapitalize) {
            out += str[i].toUpperCase();
            shouldCapitalize = false;
          } else if (str[i] === "-") {
            shouldCapitalize = true;
          } else {
            out += str[i];
          }
        }
        return out;
      }
      var browserPrefix = getPrefix();
      var classCallCheck = function(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      };
      var createClass = /* @__PURE__ */ function() {
        function defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        return function(Constructor, protoProps, staticProps) {
          if (protoProps) defineProperties(Constructor.prototype, protoProps);
          if (staticProps) defineProperties(Constructor, staticProps);
          return Constructor;
        };
      }();
      var defineProperty = function(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      };
      var _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      var inherits = function(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      };
      var possibleConstructorReturn = function(self, call) {
        if (!self) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
      };
      var slicedToArray = /* @__PURE__ */ function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var matchesSelectorFunc = "";
      function matchesSelector(el, selector) {
        if (!matchesSelectorFunc) {
          matchesSelectorFunc = findInArray(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(method) {
            return isFunction(el[method]);
          });
        }
        if (!isFunction(el[matchesSelectorFunc])) return false;
        return el[matchesSelectorFunc](selector);
      }
      function matchesSelectorAndParentsTo(el, selector, baseNode) {
        var node = el;
        do {
          if (matchesSelector(node, selector)) return true;
          if (node === baseNode) return false;
          node = node.parentNode;
        } while (node);
        return false;
      }
      function addEvent(el, event, handler) {
        if (!el) {
          return;
        }
        if (el.attachEvent) {
          el.attachEvent("on" + event, handler);
        } else if (el.addEventListener) {
          el.addEventListener(event, handler, true);
        } else {
          el["on" + event] = handler;
        }
      }
      function removeEvent(el, event, handler) {
        if (!el) {
          return;
        }
        if (el.detachEvent) {
          el.detachEvent("on" + event, handler);
        } else if (el.removeEventListener) {
          el.removeEventListener(event, handler, true);
        } else {
          el["on" + event] = null;
        }
      }
      function outerHeight(node) {
        var height = node.clientHeight;
        var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
        height += int(computedStyle.borderTopWidth);
        height += int(computedStyle.borderBottomWidth);
        return height;
      }
      function outerWidth(node) {
        var width = node.clientWidth;
        var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
        width += int(computedStyle.borderLeftWidth);
        width += int(computedStyle.borderRightWidth);
        return width;
      }
      function innerHeight(node) {
        var height = node.clientHeight;
        var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
        height -= int(computedStyle.paddingTop);
        height -= int(computedStyle.paddingBottom);
        return height;
      }
      function innerWidth(node) {
        var width = node.clientWidth;
        var computedStyle = node.ownerDocument.defaultView.getComputedStyle(node);
        width -= int(computedStyle.paddingLeft);
        width -= int(computedStyle.paddingRight);
        return width;
      }
      function offsetXYFromParent(evt, offsetParent) {
        var isBody = offsetParent === offsetParent.ownerDocument.body;
        var offsetParentRect = isBody ? { left: 0, top: 0 } : offsetParent.getBoundingClientRect();
        var x = evt.clientX + offsetParent.scrollLeft - offsetParentRect.left;
        var y = evt.clientY + offsetParent.scrollTop - offsetParentRect.top;
        return { x, y };
      }
      function createCSSTransform(controlPos, positionOffset) {
        var translation = getTranslation(controlPos, positionOffset, "px");
        return defineProperty({}, browserPrefixToKey("transform", browserPrefix), translation);
      }
      function createSVGTransform(controlPos, positionOffset) {
        var translation = getTranslation(controlPos, positionOffset, "");
        return translation;
      }
      function getTranslation(_ref2, positionOffset, unitSuffix) {
        var x = _ref2.x, y = _ref2.y;
        var translation = "translate(" + x + unitSuffix + "," + y + unitSuffix + ")";
        if (positionOffset) {
          var defaultX = "" + (typeof positionOffset.x === "string" ? positionOffset.x : positionOffset.x + unitSuffix);
          var defaultY = "" + (typeof positionOffset.y === "string" ? positionOffset.y : positionOffset.y + unitSuffix);
          translation = "translate(" + defaultX + ", " + defaultY + ")" + translation;
        }
        return translation;
      }
      function getTouch(e, identifier) {
        return e.targetTouches && findInArray(e.targetTouches, function(t) {
          return identifier === t.identifier;
        }) || e.changedTouches && findInArray(e.changedTouches, function(t) {
          return identifier === t.identifier;
        });
      }
      function getTouchIdentifier(e) {
        if (e.targetTouches && e.targetTouches[0]) return e.targetTouches[0].identifier;
        if (e.changedTouches && e.changedTouches[0]) return e.changedTouches[0].identifier;
      }
      function addUserSelectStyles(doc) {
        if (!doc) return;
        var styleEl = doc.getElementById("react-draggable-style-el");
        if (!styleEl) {
          styleEl = doc.createElement("style");
          styleEl.type = "text/css";
          styleEl.id = "react-draggable-style-el";
          styleEl.innerHTML = ".react-draggable-transparent-selection *::-moz-selection {all: inherit;}\n";
          styleEl.innerHTML += ".react-draggable-transparent-selection *::selection {all: inherit;}\n";
          doc.getElementsByTagName("head")[0].appendChild(styleEl);
        }
        if (doc.body) addClassName(doc.body, "react-draggable-transparent-selection");
      }
      function removeUserSelectStyles(doc) {
        try {
          if (doc && doc.body) removeClassName(doc.body, "react-draggable-transparent-selection");
          if (doc.selection) {
            doc.selection.empty();
          } else {
            window.getSelection().removeAllRanges();
          }
        } catch (e) {
        }
      }
      function styleHacks() {
        var childStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        return _extends({
          touchAction: "none"
        }, childStyle);
      }
      function addClassName(el, className) {
        if (el.classList) {
          el.classList.add(className);
        } else {
          if (!el.className.match(new RegExp("(?:^|\\s)" + className + "(?!\\S)"))) {
            el.className += " " + className;
          }
        }
      }
      function removeClassName(el, className) {
        if (el.classList) {
          el.classList.remove(className);
        } else {
          el.className = el.className.replace(new RegExp("(?:^|\\s)" + className + "(?!\\S)", "g"), "");
        }
      }
      function getBoundPosition(draggable, x, y) {
        if (!draggable.props.bounds) return [x, y];
        var bounds = draggable.props.bounds;
        bounds = typeof bounds === "string" ? bounds : cloneBounds(bounds);
        var node = findDOMNode(draggable);
        if (typeof bounds === "string") {
          var ownerDocument = node.ownerDocument;
          var ownerWindow = ownerDocument.defaultView;
          var boundNode = void 0;
          if (bounds === "parent") {
            boundNode = node.parentNode;
          } else {
            boundNode = ownerDocument.querySelector(bounds);
          }
          if (!(boundNode instanceof ownerWindow.HTMLElement)) {
            throw new Error('Bounds selector "' + bounds + '" could not find an element.');
          }
          var nodeStyle = ownerWindow.getComputedStyle(node);
          var boundNodeStyle = ownerWindow.getComputedStyle(boundNode);
          bounds = {
            left: -node.offsetLeft + int(boundNodeStyle.paddingLeft) + int(nodeStyle.marginLeft),
            top: -node.offsetTop + int(boundNodeStyle.paddingTop) + int(nodeStyle.marginTop),
            right: innerWidth(boundNode) - outerWidth(node) - node.offsetLeft + int(boundNodeStyle.paddingRight) - int(nodeStyle.marginRight),
            bottom: innerHeight(boundNode) - outerHeight(node) - node.offsetTop + int(boundNodeStyle.paddingBottom) - int(nodeStyle.marginBottom)
          };
        }
        if (isNum(bounds.right)) x = Math.min(x, bounds.right);
        if (isNum(bounds.bottom)) y = Math.min(y, bounds.bottom);
        if (isNum(bounds.left)) x = Math.max(x, bounds.left);
        if (isNum(bounds.top)) y = Math.max(y, bounds.top);
        return [x, y];
      }
      function snapToGrid(grid, pendingX, pendingY) {
        var x = Math.round(pendingX / grid[0]) * grid[0];
        var y = Math.round(pendingY / grid[1]) * grid[1];
        return [x, y];
      }
      function canDragX(draggable) {
        return draggable.props.axis === "both" || draggable.props.axis === "x";
      }
      function canDragY(draggable) {
        return draggable.props.axis === "both" || draggable.props.axis === "y";
      }
      function getControlPosition(e, touchIdentifier, draggableCore) {
        var touchObj = typeof touchIdentifier === "number" ? getTouch(e, touchIdentifier) : null;
        if (typeof touchIdentifier === "number" && !touchObj) return null;
        var node = findDOMNode(draggableCore);
        var offsetParent = draggableCore.props.offsetParent || node.offsetParent || node.ownerDocument.body;
        return offsetXYFromParent(touchObj || e, offsetParent);
      }
      function createCoreData(draggable, x, y) {
        var state = draggable.state;
        var isStart = !isNum(state.lastX);
        var node = findDOMNode(draggable);
        if (isStart) {
          return {
            node,
            deltaX: 0,
            deltaY: 0,
            lastX: x,
            lastY: y,
            x,
            y
          };
        } else {
          return {
            node,
            deltaX: x - state.lastX,
            deltaY: y - state.lastY,
            lastX: state.lastX,
            lastY: state.lastY,
            x,
            y
          };
        }
      }
      function createDraggableData(draggable, coreData) {
        var scale = draggable.props.scale;
        return {
          node: coreData.node,
          x: draggable.state.x + coreData.deltaX / scale,
          y: draggable.state.y + coreData.deltaY / scale,
          deltaX: coreData.deltaX / scale,
          deltaY: coreData.deltaY / scale,
          lastX: draggable.state.x,
          lastY: draggable.state.y
        };
      }
      function cloneBounds(bounds) {
        return {
          left: bounds.left,
          top: bounds.top,
          right: bounds.right,
          bottom: bounds.bottom
        };
      }
      function findDOMNode(draggable) {
        var node = ReactDOM.findDOMNode(draggable);
        if (!node) {
          throw new Error("<DraggableCore>: Unmounted during event!");
        }
        return node;
      }
      function log() {
      }
      var eventsFor = {
        touch: {
          start: "touchstart",
          move: "touchmove",
          stop: "touchend"
        },
        mouse: {
          start: "mousedown",
          move: "mousemove",
          stop: "mouseup"
        }
      };
      var dragEventFor = eventsFor.mouse;
      var DraggableCore = function(_React$Component) {
        inherits(DraggableCore2, _React$Component);
        function DraggableCore2() {
          var _ref;
          var _temp, _this, _ret;
          classCallCheck(this, DraggableCore2);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = DraggableCore2.__proto__ || Object.getPrototypeOf(DraggableCore2)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
            dragging: false,
            // Used while dragging to determine deltas.
            lastX: NaN,
            lastY: NaN,
            touchIdentifier: null
          }, _this.handleDragStart = function(e) {
            _this.props.onMouseDown(e);
            if (!_this.props.allowAnyClick && typeof e.button === "number" && e.button !== 0) return false;
            var thisNode = ReactDOM.findDOMNode(_this);
            if (!thisNode || !thisNode.ownerDocument || !thisNode.ownerDocument.body) {
              throw new Error("<DraggableCore> not mounted on DragStart!");
            }
            var ownerDocument = thisNode.ownerDocument;
            if (_this.props.disabled || !(e.target instanceof ownerDocument.defaultView.Node) || _this.props.handle && !matchesSelectorAndParentsTo(e.target, _this.props.handle, thisNode) || _this.props.cancel && matchesSelectorAndParentsTo(e.target, _this.props.cancel, thisNode)) {
              return;
            }
            var touchIdentifier = getTouchIdentifier(e);
            _this.setState({ touchIdentifier });
            var position = getControlPosition(e, touchIdentifier, _this);
            if (position == null) return;
            var x = position.x, y = position.y;
            var coreEvent = createCoreData(_this, x, y);
            log("calling", _this.props.onStart);
            var shouldUpdate = _this.props.onStart(e, coreEvent);
            if (shouldUpdate === false) return;
            if (_this.props.enableUserSelectHack) addUserSelectStyles(ownerDocument);
            _this.setState({
              dragging: true,
              lastX: x,
              lastY: y
            });
            addEvent(ownerDocument, dragEventFor.move, _this.handleDrag);
            addEvent(ownerDocument, dragEventFor.stop, _this.handleDragStop);
          }, _this.handleDrag = function(e) {
            if (e.type === "touchmove") e.preventDefault();
            var position = getControlPosition(e, _this.state.touchIdentifier, _this);
            if (position == null) return;
            var x = position.x, y = position.y;
            if (Array.isArray(_this.props.grid)) {
              var _deltaX = x - _this.state.lastX, _deltaY = y - _this.state.lastY;
              var _snapToGrid = snapToGrid(_this.props.grid, _deltaX, _deltaY);
              var _snapToGrid2 = slicedToArray(_snapToGrid, 2);
              _deltaX = _snapToGrid2[0];
              _deltaY = _snapToGrid2[1];
              if (!_deltaX && !_deltaY) return;
              x = _this.state.lastX + _deltaX, y = _this.state.lastY + _deltaY;
            }
            var coreEvent = createCoreData(_this, x, y);
            var shouldUpdate = _this.props.onDrag(e, coreEvent);
            if (shouldUpdate === false) {
              try {
                _this.handleDragStop(new MouseEvent("mouseup"));
              } catch (err) {
                var event = document.createEvent("MouseEvents");
                event.initMouseEvent("mouseup", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
                _this.handleDragStop(event);
              }
              return;
            }
            _this.setState({
              lastX: x,
              lastY: y
            });
          }, _this.handleDragStop = function(e) {
            if (!_this.state.dragging) return;
            var position = getControlPosition(e, _this.state.touchIdentifier, _this);
            if (position == null) return;
            var x = position.x, y = position.y;
            var coreEvent = createCoreData(_this, x, y);
            var thisNode = ReactDOM.findDOMNode(_this);
            if (thisNode) {
              if (_this.props.enableUserSelectHack) removeUserSelectStyles(thisNode.ownerDocument);
            }
            _this.setState({
              dragging: false,
              lastX: NaN,
              lastY: NaN
            });
            _this.props.onStop(e, coreEvent);
            if (thisNode) {
              removeEvent(thisNode.ownerDocument, dragEventFor.move, _this.handleDrag);
              removeEvent(thisNode.ownerDocument, dragEventFor.stop, _this.handleDragStop);
            }
          }, _this.onMouseDown = function(e) {
            dragEventFor = eventsFor.mouse;
            return _this.handleDragStart(e);
          }, _this.onMouseUp = function(e) {
            dragEventFor = eventsFor.mouse;
            return _this.handleDragStop(e);
          }, _this.onTouchStart = function(e) {
            dragEventFor = eventsFor.touch;
            return _this.handleDragStart(e);
          }, _this.onTouchEnd = function(e) {
            dragEventFor = eventsFor.touch;
            return _this.handleDragStop(e);
          }, _temp), possibleConstructorReturn(_this, _ret);
        }
        createClass(DraggableCore2, [{
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            var thisNode = ReactDOM.findDOMNode(this);
            if (thisNode) {
              var ownerDocument = thisNode.ownerDocument;
              removeEvent(ownerDocument, eventsFor.mouse.move, this.handleDrag);
              removeEvent(ownerDocument, eventsFor.touch.move, this.handleDrag);
              removeEvent(ownerDocument, eventsFor.mouse.stop, this.handleDragStop);
              removeEvent(ownerDocument, eventsFor.touch.stop, this.handleDragStop);
              if (this.props.enableUserSelectHack) removeUserSelectStyles(ownerDocument);
            }
          }
          // Same as onMouseDown (start drag), but now consider this a touch device.
        }, {
          key: "render",
          value: function render() {
            return React.cloneElement(React.Children.only(this.props.children), {
              style: styleHacks(this.props.children.props.style),
              // Note: mouseMove handler is attached to document so it will still function
              // when the user drags quickly and leaves the bounds of the element.
              onMouseDown: this.onMouseDown,
              onTouchStart: this.onTouchStart,
              onMouseUp: this.onMouseUp,
              onTouchEnd: this.onTouchEnd
            });
          }
        }]);
        return DraggableCore2;
      }(React.Component);
      DraggableCore.displayName = "DraggableCore";
      DraggableCore.propTypes = {
        /**
         * `allowAnyClick` allows dragging using any mouse button.
         * By default, we only accept the left button.
         *
         * Defaults to `false`.
         */
        allowAnyClick: propTypes.bool,
        /**
         * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
         * with the exception of `onMouseDown`, will not fire.
         */
        disabled: propTypes.bool,
        /**
         * By default, we add 'user-select:none' attributes to the document body
         * to prevent ugly text selection during drag. If this is causing problems
         * for your app, set this to `false`.
         */
        enableUserSelectHack: propTypes.bool,
        /**
         * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
         * instead of using the parent node.
         */
        offsetParent: function offsetParent(props, propName) {
          if (props[propName] && props[propName].nodeType !== 1) {
            throw new Error("Draggable's offsetParent must be a DOM Node.");
          }
        },
        /**
         * `grid` specifies the x and y that dragging should snap to.
         */
        grid: propTypes.arrayOf(propTypes.number),
        /**
         * `scale` specifies the scale of the area you are dragging inside of. It allows
         * the drag deltas to scale correctly with how far zoomed in/out you are.
         */
        scale: propTypes.number,
        /**
         * `handle` specifies a selector to be used as the handle that initiates drag.
         *
         * Example:
         *
         * ```jsx
         *   let App = React.createClass({
         *       render: function () {
         *         return (
         *            <Draggable handle=".handle">
         *              <div>
         *                  <div className="handle">Click me to drag</div>
         *                  <div>This is some other content</div>
         *              </div>
         *           </Draggable>
         *         );
         *       }
         *   });
         * ```
         */
        handle: propTypes.string,
        /**
         * `cancel` specifies a selector to be used to prevent drag initialization.
         *
         * Example:
         *
         * ```jsx
         *   let App = React.createClass({
         *       render: function () {
         *           return(
         *               <Draggable cancel=".cancel">
         *                   <div>
         *                     <div className="cancel">You can't drag from here</div>
         *                     <div>Dragging here works fine</div>
         *                   </div>
         *               </Draggable>
         *           );
         *       }
         *   });
         * ```
         */
        cancel: propTypes.string,
        /**
         * Called when dragging starts.
         * If this function returns the boolean false, dragging will be canceled.
         */
        onStart: propTypes.func,
        /**
         * Called while dragging.
         * If this function returns the boolean false, dragging will be canceled.
         */
        onDrag: propTypes.func,
        /**
         * Called when dragging stops.
         * If this function returns the boolean false, the drag will remain active.
         */
        onStop: propTypes.func,
        /**
         * A workaround option which can be passed if onMouseDown needs to be accessed,
         * since it'll always be blocked (as there is internal use of onMouseDown)
         */
        onMouseDown: propTypes.func,
        /**
         * These properties should be defined on the child, not here.
         */
        className: dontSetMe,
        style: dontSetMe,
        transform: dontSetMe
      };
      DraggableCore.defaultProps = {
        allowAnyClick: false,
        // by default only accept left click
        cancel: null,
        disabled: false,
        enableUserSelectHack: true,
        offsetParent: null,
        handle: null,
        grid: null,
        transform: null,
        onStart: function onStart() {
        },
        onDrag: function onDrag() {
        },
        onStop: function onStop() {
        },
        onMouseDown: function onMouseDown() {
        }
      };
      var Draggable = function(_React$Component) {
        inherits(Draggable2, _React$Component);
        function Draggable2(props) {
          classCallCheck(this, Draggable2);
          var _this = possibleConstructorReturn(this, (Draggable2.__proto__ || Object.getPrototypeOf(Draggable2)).call(this, props));
          _this.onDragStart = function(e, coreData) {
            var shouldStart = _this.props.onStart(e, createDraggableData(_this, coreData));
            if (shouldStart === false) return false;
            _this.setState({ dragging: true, dragged: true });
          };
          _this.onDrag = function(e, coreData) {
            if (!_this.state.dragging) return false;
            var uiData = createDraggableData(_this, coreData);
            var newState = {
              x: uiData.x,
              y: uiData.y
            };
            if (_this.props.bounds) {
              var _x = newState.x, _y = newState.y;
              newState.x += _this.state.slackX;
              newState.y += _this.state.slackY;
              var _getBoundPosition = getBoundPosition(_this, newState.x, newState.y), _getBoundPosition2 = slicedToArray(_getBoundPosition, 2), newStateX = _getBoundPosition2[0], newStateY = _getBoundPosition2[1];
              newState.x = newStateX;
              newState.y = newStateY;
              newState.slackX = _this.state.slackX + (_x - newState.x);
              newState.slackY = _this.state.slackY + (_y - newState.y);
              uiData.x = newState.x;
              uiData.y = newState.y;
              uiData.deltaX = newState.x - _this.state.x;
              uiData.deltaY = newState.y - _this.state.y;
            }
            var shouldUpdate = _this.props.onDrag(e, uiData);
            if (shouldUpdate === false) return false;
            _this.setState(newState);
          };
          _this.onDragStop = function(e, coreData) {
            if (!_this.state.dragging) return false;
            var shouldStop = _this.props.onStop(e, createDraggableData(_this, coreData));
            if (shouldStop === false) return false;
            var newState = {
              dragging: false,
              slackX: 0,
              slackY: 0
            };
            var controlled = Boolean(_this.props.position);
            if (controlled) {
              var _this$props$position = _this.props.position, _x2 = _this$props$position.x, _y2 = _this$props$position.y;
              newState.x = _x2;
              newState.y = _y2;
            }
            _this.setState(newState);
          };
          _this.state = {
            // Whether or not we are currently dragging.
            dragging: false,
            // Whether or not we have been dragged before.
            dragged: false,
            // Current transform x and y.
            x: props.position ? props.position.x : props.defaultPosition.x,
            y: props.position ? props.position.y : props.defaultPosition.y,
            // Used for compensating for out-of-bounds drags
            slackX: 0,
            slackY: 0,
            // Can only determine if SVG after mounting
            isElementSVG: false
          };
          if (props.position && !(props.onDrag || props.onStop)) {
            console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
          }
          return _this;
        }
        createClass(Draggable2, [{
          key: "componentDidMount",
          value: function componentDidMount() {
            if (typeof window.SVGElement !== "undefined" && ReactDOM.findDOMNode(this) instanceof window.SVGElement) {
              this.setState({ isElementSVG: true });
            }
          }
        }, {
          key: "componentWillReceiveProps",
          value: function componentWillReceiveProps(nextProps) {
            if (nextProps.position && (!this.props.position || nextProps.position.x !== this.props.position.x || nextProps.position.y !== this.props.position.y)) {
              this.setState({ x: nextProps.position.x, y: nextProps.position.y });
            }
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.setState({ dragging: false });
          }
        }, {
          key: "render",
          value: function render() {
            var _classNames;
            var style = {}, svgTransform = null;
            var controlled = Boolean(this.props.position);
            var draggable = !controlled || this.state.dragging;
            var position = this.props.position || this.props.defaultPosition;
            var transformOpts = {
              // Set left if horizontal drag is enabled
              x: canDragX(this) && draggable ? this.state.x : position.x,
              // Set top if vertical drag is enabled
              y: canDragY(this) && draggable ? this.state.y : position.y
            };
            if (this.state.isElementSVG) {
              svgTransform = createSVGTransform(transformOpts, this.props.positionOffset);
            } else {
              style = createCSSTransform(transformOpts, this.props.positionOffset);
            }
            var _props = this.props, defaultClassName = _props.defaultClassName, defaultClassNameDragging = _props.defaultClassNameDragging, defaultClassNameDragged = _props.defaultClassNameDragged;
            var children = React.Children.only(this.props.children);
            var className = classnames(children.props.className || "", defaultClassName, (_classNames = {}, defineProperty(_classNames, defaultClassNameDragging, this.state.dragging), defineProperty(_classNames, defaultClassNameDragged, this.state.dragged), _classNames));
            return React.createElement(
              DraggableCore,
              _extends({}, this.props, { onStart: this.onDragStart, onDrag: this.onDrag, onStop: this.onDragStop }),
              React.cloneElement(children, {
                className,
                style: _extends({}, children.props.style, style),
                transform: svgTransform
              })
            );
          }
        }]);
        return Draggable2;
      }(React.Component);
      Draggable.displayName = "Draggable";
      Draggable.propTypes = _extends({}, DraggableCore.propTypes, {
        /**
         * `axis` determines which axis the draggable can move.
         *
         *  Note that all callbacks will still return data as normal. This only
         *  controls flushing to the DOM.
         *
         * 'both' allows movement horizontally and vertically.
         * 'x' limits movement to horizontal axis.
         * 'y' limits movement to vertical axis.
         * 'none' limits all movement.
         *
         * Defaults to 'both'.
         */
        axis: propTypes.oneOf(["both", "x", "y", "none"]),
        /**
         * `bounds` determines the range of movement available to the element.
         * Available values are:
         *
         * 'parent' restricts movement within the Draggable's parent node.
         *
         * Alternatively, pass an object with the following properties, all of which are optional:
         *
         * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
         *
         * All values are in px.
         *
         * Example:
         *
         * ```jsx
         *   let App = React.createClass({
         *       render: function () {
         *         return (
         *            <Draggable bounds={{right: 300, bottom: 300}}>
         *              <div>Content</div>
         *           </Draggable>
         *         );
         *       }
         *   });
         * ```
         */
        bounds: propTypes.oneOfType([propTypes.shape({
          left: propTypes.number,
          right: propTypes.number,
          top: propTypes.number,
          bottom: propTypes.number
        }), propTypes.string, propTypes.oneOf([false])]),
        defaultClassName: propTypes.string,
        defaultClassNameDragging: propTypes.string,
        defaultClassNameDragged: propTypes.string,
        /**
         * `defaultPosition` specifies the x and y that the dragged item should start at
         *
         * Example:
         *
         * ```jsx
         *      let App = React.createClass({
         *          render: function () {
         *              return (
         *                  <Draggable defaultPosition={{x: 25, y: 25}}>
         *                      <div>I start with transformX: 25px and transformY: 25px;</div>
         *                  </Draggable>
         *              );
         *          }
         *      });
         * ```
         */
        defaultPosition: propTypes.shape({
          x: propTypes.number,
          y: propTypes.number
        }),
        positionOffset: propTypes.shape({
          x: propTypes.oneOfType([propTypes.number, propTypes.string]),
          y: propTypes.oneOfType([propTypes.number, propTypes.string])
        }),
        /**
         * `position`, if present, defines the current position of the element.
         *
         *  This is similar to how form elements in React work - if no `position` is supplied, the component
         *  is uncontrolled.
         *
         * Example:
         *
         * ```jsx
         *      let App = React.createClass({
         *          render: function () {
         *              return (
         *                  <Draggable position={{x: 25, y: 25}}>
         *                      <div>I start with transformX: 25px and transformY: 25px;</div>
         *                  </Draggable>
         *              );
         *          }
         *      });
         * ```
         */
        position: propTypes.shape({
          x: propTypes.number,
          y: propTypes.number
        }),
        /**
         * These properties should be defined on the child, not here.
         */
        className: dontSetMe,
        style: dontSetMe,
        transform: dontSetMe
      });
      Draggable.defaultProps = _extends({}, DraggableCore.defaultProps, {
        axis: "both",
        bounds: false,
        defaultClassName: "react-draggable",
        defaultClassNameDragging: "react-draggable-dragging",
        defaultClassNameDragged: "react-draggable-dragged",
        defaultPosition: { x: 0, y: 0 },
        position: null,
        scale: 1
      });
      Draggable.default = Draggable;
      Draggable.DraggableCore = DraggableCore;
      return Draggable;
    });
  }
});
export default require_react_draggable();
/*! Bundled license information:

react-draggable/dist/react-draggable.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
  (*!
    Copyright (c) 2016 Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=react-draggable.js.map
