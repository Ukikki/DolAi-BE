import {
  require_browser
} from "./chunk-HXDJRASA.js";
import {
  __commonJS
} from "./chunk-PWCYJDAR.js";

// node_modules/protoo-client/package.json
var require_package = __commonJS({
  "node_modules/protoo-client/package.json"(exports, module) {
    module.exports = {
      name: "protoo-client",
      version: "4.0.5",
      description: "protoo JavaScript client module",
      author: "Iñaki Baz Castillo <ibc@aliax.net>",
      homepage: "https://protoo.versatica.com",
      license: "MIT",
      repository: {
        type: "git",
        url: "https://github.com/ibc/protoo.git"
      },
      main: "lib/index.js",
      keywords: [
        "nodejs",
        "browser",
        "websocket"
      ],
      engines: {
        node: ">=8.0.0"
      },
      scripts: {
        lint: "eslint -c .eslintrc.js lib"
      },
      dependencies: {
        debug: "^4.3.1",
        events: "^3.2.0",
        retry: "^0.12.0"
      },
      devDependencies: {
        eslint: "^5.16.0"
      },
      optionalDependencies: {
        websocket: "^1.0.33"
      }
    };
  }
});

// node_modules/protoo-client/lib/Logger.js
var require_Logger = __commonJS({
  "node_modules/protoo-client/lib/Logger.js"(exports, module) {
    var debug = require_browser();
    var APP_NAME = "protoo-client";
    var Logger = class {
      constructor(prefix) {
        if (prefix) {
          this._debug = debug(`${APP_NAME}:${prefix}`);
          this._warn = debug(`${APP_NAME}:WARN:${prefix}`);
          this._error = debug(`${APP_NAME}:ERROR:${prefix}`);
        } else {
          this._debug = debug(APP_NAME);
          this._warn = debug(`${APP_NAME}:WARN`);
          this._error = debug(`${APP_NAME}:ERROR`);
        }
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
      }
      get debug() {
        return this._debug;
      }
      get warn() {
        return this._warn;
      }
      get error() {
        return this._error;
      }
    };
    module.exports = Logger;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/protoo-client/lib/EnhancedEventEmitter.js
var require_EnhancedEventEmitter = __commonJS({
  "node_modules/protoo-client/lib/EnhancedEventEmitter.js"(exports, module) {
    var { EventEmitter } = require_events();
    var Logger = require_Logger();
    var EnhancedEventEmitter = class extends EventEmitter {
      constructor(logger) {
        super();
        this.setMaxListeners(Infinity);
        this._logger = logger || new Logger("EnhancedEventEmitter");
      }
      safeEmit(event, ...args) {
        try {
          this.emit(event, ...args);
        } catch (error) {
          this._logger.error(
            "safeEmit() | event listener threw an error [event:%s]:%o",
            event,
            error
          );
        }
      }
      async safeEmitAsPromise(event, ...args) {
        return new Promise((resolve, reject) => {
          this.safeEmit(event, ...args, resolve, reject);
        });
      }
    };
    module.exports = EnhancedEventEmitter;
  }
});

// node_modules/protoo-client/lib/utils.js
var require_utils = __commonJS({
  "node_modules/protoo-client/lib/utils.js"(exports) {
    exports.generateRandomNumber = function() {
      return Math.round(Math.random() * 1e7);
    };
  }
});

// node_modules/protoo-client/lib/Message.js
var require_Message = __commonJS({
  "node_modules/protoo-client/lib/Message.js"(exports, module) {
    var Logger = require_Logger();
    var { generateRandomNumber } = require_utils();
    var logger = new Logger("Message");
    var Message = class {
      static parse(raw) {
        let object;
        const message = {};
        try {
          object = JSON.parse(raw);
        } catch (error) {
          logger.error("parse() | invalid JSON: %s", error);
          return;
        }
        if (typeof object !== "object" || Array.isArray(object)) {
          logger.error("parse() | not an object");
          return;
        }
        if (object.request) {
          message.request = true;
          if (typeof object.method !== "string") {
            logger.error("parse() | missing/invalid method field");
            return;
          }
          if (typeof object.id !== "number") {
            logger.error("parse() | missing/invalid id field");
            return;
          }
          message.id = object.id;
          message.method = object.method;
          message.data = object.data || {};
        } else if (object.response) {
          message.response = true;
          if (typeof object.id !== "number") {
            logger.error("parse() | missing/invalid id field");
            return;
          }
          message.id = object.id;
          if (object.ok) {
            message.ok = true;
            message.data = object.data || {};
          } else {
            message.ok = false;
            message.errorCode = object.errorCode;
            message.errorReason = object.errorReason;
          }
        } else if (object.notification) {
          message.notification = true;
          if (typeof object.method !== "string") {
            logger.error("parse() | missing/invalid method field");
            return;
          }
          message.method = object.method;
          message.data = object.data || {};
        } else {
          logger.error("parse() | missing request/response field");
          return;
        }
        return message;
      }
      static createRequest(method, data) {
        const request = {
          request: true,
          id: generateRandomNumber(),
          method,
          data: data || {}
        };
        return request;
      }
      static createSuccessResponse(request, data) {
        const response = {
          response: true,
          id: request.id,
          ok: true,
          data: data || {}
        };
        return response;
      }
      static createErrorResponse(request, errorCode, errorReason) {
        const response = {
          response: true,
          id: request.id,
          ok: false,
          errorCode,
          errorReason
        };
        return response;
      }
      static createNotification(method, data) {
        const notification = {
          notification: true,
          method,
          data: data || {}
        };
        return notification;
      }
    };
    module.exports = Message;
  }
});

// node_modules/protoo-client/lib/Peer.js
var require_Peer = __commonJS({
  "node_modules/protoo-client/lib/Peer.js"(exports, module) {
    var Logger = require_Logger();
    var EnhancedEventEmitter = require_EnhancedEventEmitter();
    var Message = require_Message();
    var logger = new Logger("Peer");
    var Peer = class extends EnhancedEventEmitter {
      /**
       * @param {protoo.Transport} transport
       *
       * @emits open
       * @emits {currentAttempt: Number} failed
       * @emits disconnected
       * @emits close
       * @emits {request: protoo.Request, accept: Function, reject: Function} request
       * @emits {notification: protoo.Notification} notification
       */
      constructor(transport) {
        super(logger);
        logger.debug("constructor()");
        this._closed = false;
        this._transport = transport;
        this._connected = false;
        this._data = {};
        this._sents = /* @__PURE__ */ new Map();
        this._handleTransport();
      }
      /**
       * Whether the Peer is closed.
       *
       * @returns {Boolean}
       */
      get closed() {
        return this._closed;
      }
      /**
       * Whether the Peer is connected.
       *
       * @returns {Boolean}
       */
      get connected() {
        return this._connected;
      }
      /**
       * App custom data.
       *
       * @returns {Object}
       */
      get data() {
        return this._data;
      }
      /**
       * Invalid setter.
       */
      set data(data) {
        throw new Error("cannot override data object");
      }
      /**
       * Close this Peer and its Transport.
       */
      close() {
        if (this._closed)
          return;
        logger.debug("close()");
        this._closed = true;
        this._connected = false;
        this._transport.close();
        for (const sent of this._sents.values()) {
          sent.close();
        }
        this.safeEmit("close");
      }
      /**
       * Send a protoo request to the server-side Room.
       *
       * @param {String} method
       * @param {Object} [data]
       *
       * @async
       * @returns {Object} The response data Object if a success response is received.
       */
      async request(method, data = void 0) {
        const request = Message.createRequest(method, data);
        this._logger.debug("request() [method:%s, id:%s]", method, request.id);
        await this._transport.send(request);
        return new Promise((pResolve, pReject) => {
          const timeout = 1500 * (15 + 0.1 * this._sents.size);
          const sent = {
            id: request.id,
            method: request.method,
            resolve: (data2) => {
              if (!this._sents.delete(request.id))
                return;
              clearTimeout(sent.timer);
              pResolve(data2);
            },
            reject: (error) => {
              if (!this._sents.delete(request.id))
                return;
              clearTimeout(sent.timer);
              pReject(error);
            },
            timer: setTimeout(() => {
              if (!this._sents.delete(request.id))
                return;
              pReject(new Error("request timeout"));
            }, timeout),
            close: () => {
              clearTimeout(sent.timer);
              pReject(new Error("peer closed"));
            }
          };
          this._sents.set(request.id, sent);
        });
      }
      /**
       * Send a protoo notification to the server-side Room.
       *
       * @param {String} method
       * @param {Object} [data]
       *
       * @async
       */
      async notify(method, data = void 0) {
        const notification = Message.createNotification(method, data);
        this._logger.debug("notify() [method:%s]", method);
        await this._transport.send(notification);
      }
      _handleTransport() {
        if (this._transport.closed) {
          this._closed = true;
          setTimeout(() => {
            if (this._closed)
              return;
            this._connected = false;
            this.safeEmit("close");
          });
          return;
        }
        this._transport.on("open", () => {
          if (this._closed)
            return;
          logger.debug('emit "open"');
          this._connected = true;
          this.safeEmit("open");
        });
        this._transport.on("disconnected", () => {
          if (this._closed)
            return;
          logger.debug('emit "disconnected"');
          this._connected = false;
          this.safeEmit("disconnected");
        });
        this._transport.on("failed", (currentAttempt) => {
          if (this._closed)
            return;
          logger.debug('emit "failed" [currentAttempt:%s]', currentAttempt);
          this._connected = false;
          this.safeEmit("failed", currentAttempt);
        });
        this._transport.on("close", () => {
          if (this._closed)
            return;
          this._closed = true;
          logger.debug('emit "close"');
          this._connected = false;
          this.safeEmit("close");
        });
        this._transport.on("message", (message) => {
          if (message.request)
            this._handleRequest(message);
          else if (message.response)
            this._handleResponse(message);
          else if (message.notification)
            this._handleNotification(message);
        });
      }
      _handleRequest(request) {
        try {
          this.emit(
            "request",
            // Request.
            request,
            // accept() function.
            (data) => {
              const response = Message.createSuccessResponse(request, data);
              this._transport.send(response).catch(() => {
              });
            },
            // reject() function.
            (errorCode, errorReason) => {
              if (errorCode instanceof Error) {
                errorCode = 500;
                errorReason = String(errorCode);
              } else if (typeof errorCode === "number" && errorReason instanceof Error) {
                errorReason = String(errorReason);
              }
              const response = Message.createErrorResponse(request, errorCode, errorReason);
              this._transport.send(response).catch(() => {
              });
            }
          );
        } catch (error) {
          const response = Message.createErrorResponse(request, 500, String(error));
          this._transport.send(response).catch(() => {
          });
        }
      }
      _handleResponse(response) {
        const sent = this._sents.get(response.id);
        if (!sent) {
          logger.error(
            "received response does not match any sent request [id:%s]",
            response.id
          );
          return;
        }
        if (response.ok) {
          sent.resolve(response.data);
        } else {
          const error = new Error(response.errorReason);
          error.code = response.errorCode;
          sent.reject(error);
        }
      }
      _handleNotification(notification) {
        this.safeEmit("notification", notification);
      }
    };
    module.exports = Peer;
  }
});

// node_modules/es5-ext/global.js
var require_global = __commonJS({
  "node_modules/es5-ext/global.js"(exports, module) {
    var naiveFallback = function() {
      if (typeof self === "object" && self) return self;
      if (typeof window === "object" && window) return window;
      throw new Error("Unable to resolve global `this`");
    };
    module.exports = function() {
      if (this) return this;
      if (typeof globalThis === "object" && globalThis) return globalThis;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function() {
            return this;
          },
          configurable: true
        });
      } catch (error) {
        return naiveFallback();
      }
      try {
        if (!__global__) return naiveFallback();
        return __global__;
      } finally {
        delete Object.prototype.__global__;
      }
    }();
  }
});

// node_modules/websocket/package.json
var require_package2 = __commonJS({
  "node_modules/websocket/package.json"(exports, module) {
    module.exports = {
      name: "websocket",
      description: "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
      keywords: [
        "websocket",
        "websockets",
        "socket",
        "networking",
        "comet",
        "push",
        "RFC-6455",
        "realtime",
        "server",
        "client"
      ],
      author: "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
      contributors: [
        "Iñaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
      ],
      version: "1.0.35",
      repository: {
        type: "git",
        url: "https://github.com/theturtle32/WebSocket-Node.git"
      },
      homepage: "https://github.com/theturtle32/WebSocket-Node",
      engines: {
        node: ">=4.0.0"
      },
      dependencies: {
        bufferutil: "^4.0.1",
        debug: "^2.2.0",
        "es5-ext": "^0.10.63",
        "typedarray-to-buffer": "^3.1.5",
        "utf-8-validate": "^5.0.2",
        yaeti: "^0.0.6"
      },
      devDependencies: {
        "buffer-equal": "^1.0.0",
        gulp: "^4.0.2",
        "gulp-jshint": "^2.0.4",
        "jshint-stylish": "^2.2.1",
        jshint: "^2.0.0",
        tape: "^4.9.1"
      },
      config: {
        verbose: false
      },
      scripts: {
        test: "tape test/unit/*.js",
        gulp: "gulp"
      },
      main: "index",
      directories: {
        lib: "./lib"
      },
      browser: "lib/browser.js",
      license: "Apache-2.0"
    };
  }
});

// node_modules/websocket/lib/version.js
var require_version = __commonJS({
  "node_modules/websocket/lib/version.js"(exports, module) {
    module.exports = require_package2().version;
  }
});

// node_modules/websocket/lib/browser.js
var require_browser2 = __commonJS({
  "node_modules/websocket/lib/browser.js"(exports, module) {
    var _globalThis;
    if (typeof globalThis === "object") {
      _globalThis = globalThis;
    } else {
      try {
        _globalThis = require_global();
      } catch (error) {
      } finally {
        if (!_globalThis && typeof window !== "undefined") {
          _globalThis = window;
        }
        if (!_globalThis) {
          throw new Error("Could not determine global this");
        }
      }
    }
    var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
    var websocket_version = require_version();
    function W3CWebSocket(uri, protocols) {
      var native_instance;
      if (protocols) {
        native_instance = new NativeWebSocket(uri, protocols);
      } else {
        native_instance = new NativeWebSocket(uri);
      }
      return native_instance;
    }
    if (NativeWebSocket) {
      ["CONNECTING", "OPEN", "CLOSING", "CLOSED"].forEach(function(prop) {
        Object.defineProperty(W3CWebSocket, prop, {
          get: function() {
            return NativeWebSocket[prop];
          }
        });
      });
    }
    module.exports = {
      "w3cwebsocket": NativeWebSocket ? W3CWebSocket : null,
      "version": websocket_version
    };
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports, module) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self2 = this;
      var timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports) {
    var RetryOperation = require_retry_operation();
    exports.operation = function(options) {
      var timeouts = exports.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = (function retryWrapper(original2) {
          var op = exports.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }).bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports, module) {
    module.exports = require_retry();
  }
});

// node_modules/protoo-client/lib/transports/WebSocketTransport.js
var require_WebSocketTransport = __commonJS({
  "node_modules/protoo-client/lib/transports/WebSocketTransport.js"(exports, module) {
    var W3CWebSocket = require_browser2().w3cwebsocket;
    var retry = require_retry2();
    var Logger = require_Logger();
    var EnhancedEventEmitter = require_EnhancedEventEmitter();
    var Message = require_Message();
    var WS_SUBPROTOCOL = "protoo";
    var DEFAULT_RETRY_OPTIONS = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: 8 * 1e3
    };
    var logger = new Logger("WebSocketTransport");
    var WebSocketTransport = class extends EnhancedEventEmitter {
      /**
       * @param {String} url - WebSocket URL.
       * @param {Object} [options] - Options for WebSocket-Node.W3CWebSocket and retry.
       */
      constructor(url, options) {
        super(logger);
        logger.debug("constructor() [url:%s, options:%o]", url, options);
        this._closed = false;
        this._url = url;
        this._options = options || {};
        this._ws = null;
        this._runWebSocket();
      }
      get closed() {
        return this._closed;
      }
      close() {
        if (this._closed)
          return;
        logger.debug("close()");
        this._closed = true;
        this.safeEmit("close");
        try {
          this._ws.onopen = null;
          this._ws.onclose = null;
          this._ws.onerror = null;
          this._ws.onmessage = null;
          this._ws.close();
        } catch (error) {
          logger.error("close() | error closing the WebSocket: %o", error);
        }
      }
      async send(message) {
        if (this._closed)
          throw new Error("transport closed");
        try {
          this._ws.send(JSON.stringify(message));
        } catch (error) {
          logger.warn("send() failed:%o", error);
          throw error;
        }
      }
      _runWebSocket() {
        const operation = retry.operation(this._options.retry || DEFAULT_RETRY_OPTIONS);
        let wasConnected = false;
        operation.attempt((currentAttempt) => {
          if (this._closed) {
            operation.stop();
            return;
          }
          logger.debug("_runWebSocket() [currentAttempt:%s]", currentAttempt);
          this._ws = new W3CWebSocket(
            this._url,
            WS_SUBPROTOCOL,
            this._options.origin,
            this._options.headers,
            this._options.requestOptions,
            this._options.clientConfig
          );
          this._ws.onopen = () => {
            if (this._closed)
              return;
            wasConnected = true;
            this.safeEmit("open");
          };
          this._ws.onclose = (event) => {
            if (this._closed)
              return;
            logger.warn(
              'WebSocket "close" event [wasClean:%s, code:%s, reason:"%s"]',
              event.wasClean,
              event.code,
              event.reason
            );
            if (event.code !== 4e3) {
              if (!wasConnected) {
                this.safeEmit("failed", currentAttempt);
                if (this._closed)
                  return;
                if (operation.retry(true))
                  return;
              } else {
                operation.stop();
                this.safeEmit("disconnected");
                if (this._closed)
                  return;
                this._runWebSocket();
                return;
              }
            }
            this._closed = true;
            this.safeEmit("close");
          };
          this._ws.onerror = () => {
            if (this._closed)
              return;
            logger.error('WebSocket "error" event');
          };
          this._ws.onmessage = (event) => {
            if (this._closed)
              return;
            const message = Message.parse(event.data);
            if (!message)
              return;
            if (this.listenerCount("message") === 0) {
              logger.error(
                'no listeners for WebSocket "message" event, ignoring received message'
              );
              return;
            }
            this.safeEmit("message", message);
          };
        });
      }
    };
    module.exports = WebSocketTransport;
  }
});

// node_modules/protoo-client/lib/index.js
var require_lib = __commonJS({
  "node_modules/protoo-client/lib/index.js"(exports) {
    var { version } = require_package();
    var Peer = require_Peer();
    var WebSocketTransport = require_WebSocketTransport();
    exports.version = version;
    exports.Peer = Peer;
    exports.WebSocketTransport = WebSocketTransport;
  }
});
export default require_lib();
//# sourceMappingURL=protoo-client.js.map
