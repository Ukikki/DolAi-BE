{
  "version": 3,
  "sources": ["../../wildemitter/wildemitter.js", "../../hark/hark.js"],
  "sourcesContent": ["/*\nWildEmitter.js is a slim little event emitter by @henrikjoreteg largely based\non @visionmedia's Emitter from UI Kit.\n\nWhy? I wanted it standalone.\n\nI also wanted support for wildcard emitters like this:\n\nemitter.on('*', function (eventName, other, event, payloads) {\n\n});\n\nemitter.on('somenamespace*', function (eventName, payloads) {\n\n});\n\nPlease note that callbacks triggered by wildcard registered events also get\nthe event name as the first argument.\n*/\n\nmodule.exports = WildEmitter;\n\nfunction WildEmitter() { }\n\nWildEmitter.mixin = function (constructor) {\n    var prototype = constructor.prototype || constructor;\n\n    prototype.isWildEmitter= true;\n\n    // Listen on the given `event` with `fn`. Store a group name if present.\n    prototype.on = function (event, groupName, fn) {\n        this.callbacks = this.callbacks || {};\n        var hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        func._groupName = group;\n        (this.callbacks[event] = this.callbacks[event] || []).push(func);\n        return this;\n    };\n\n    // Adds an `event` listener that will be invoked a single\n    // time then automatically removed.\n    prototype.once = function (event, groupName, fn) {\n        var self = this,\n            hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        function on() {\n            self.off(event, on);\n            func.apply(this, arguments);\n        }\n        this.on(event, group, on);\n        return this;\n    };\n\n    // Unbinds an entire group\n    prototype.releaseGroup = function (groupName) {\n        this.callbacks = this.callbacks || {};\n        var item, i, len, handlers;\n        for (item in this.callbacks) {\n            handlers = this.callbacks[item];\n            for (i = 0, len = handlers.length; i < len; i++) {\n                if (handlers[i]._groupName === groupName) {\n                    //console.log('removing');\n                    // remove it and shorten the array we're looping through\n                    handlers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n        return this;\n    };\n\n    // Remove the given callback for `event` or all\n    // registered callbacks.\n    prototype.off = function (event, fn) {\n        this.callbacks = this.callbacks || {};\n        var callbacks = this.callbacks[event],\n            i;\n\n        if (!callbacks) return this;\n\n        // remove all handlers\n        if (arguments.length === 1) {\n            delete this.callbacks[event];\n            return this;\n        }\n\n        // remove specific handler\n        i = callbacks.indexOf(fn);\n        if (i !== -1) {\n            callbacks.splice(i, 1);\n            if (callbacks.length === 0) {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    };\n\n    /// Emit `event` with the given args.\n    // also calls any `*` handlers\n    prototype.emit = function (event) {\n        this.callbacks = this.callbacks || {};\n        var args = [].slice.call(arguments, 1),\n            callbacks = this.callbacks[event],\n            specialCallbacks = this.getWildcardCallbacks(event),\n            i,\n            len,\n            item,\n            listeners;\n\n        if (callbacks) {\n            listeners = callbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, args);\n            }\n        }\n\n        if (specialCallbacks) {\n            len = specialCallbacks.length;\n            listeners = specialCallbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, [event].concat(args));\n            }\n        }\n\n        return this;\n    };\n\n    // Helper for for finding special wildcard event handlers that match the event\n    prototype.getWildcardCallbacks = function (eventName) {\n        this.callbacks = this.callbacks || {};\n        var item,\n            split,\n            result = [];\n\n        for (item in this.callbacks) {\n            split = item.split('*');\n            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {\n                result = result.concat(this.callbacks[item]);\n            }\n        }\n        return result;\n    };\n\n};\n\nWildEmitter.mixin(WildEmitter);\n", "var WildEmitter = require('wildemitter');\n\nfunction getMaxVolume (analyser, fftBins) {\n  var maxVolume = -Infinity;\n  analyser.getFloatFrequencyData(fftBins);\n\n  for(var i=4, ii=fftBins.length; i < ii; i++) {\n    if (fftBins[i] > maxVolume && fftBins[i] < 0) {\n      maxVolume = fftBins[i];\n    }\n  };\n\n  return maxVolume;\n}\n\n\nvar audioContextType;\nif (typeof window !== 'undefined') {\n  audioContextType = window.AudioContext || window.webkitAudioContext;\n}\n// use a single audio context due to hardware limits\nvar audioContext = null;\nmodule.exports = function(stream, options) {\n  var harker = new WildEmitter();\n\n  // make it not break in non-supported browsers\n  if (!audioContextType) return harker;\n\n  //Config\n  var options = options || {},\n      smoothing = (options.smoothing || 0.1),\n      interval = (options.interval || 50),\n      threshold = options.threshold,\n      play = options.play,\n      history = options.history || 10,\n      running = true;\n\n  // Ensure that just a single AudioContext is internally created\n  audioContext = options.audioContext || audioContext || new audioContextType();\n\n  var sourceNode, fftBins, analyser;\n\n  analyser = audioContext.createAnalyser();\n  analyser.fftSize = 512;\n  analyser.smoothingTimeConstant = smoothing;\n  fftBins = new Float32Array(analyser.frequencyBinCount);\n\n  if (stream.jquery) stream = stream[0];\n  if (stream instanceof HTMLAudioElement || stream instanceof HTMLVideoElement) {\n    //Audio Tag\n    sourceNode = audioContext.createMediaElementSource(stream);\n    if (typeof play === 'undefined') play = true;\n    threshold = threshold || -50;\n  } else {\n    //WebRTC Stream\n    sourceNode = audioContext.createMediaStreamSource(stream);\n    threshold = threshold || -50;\n  }\n\n  sourceNode.connect(analyser);\n  if (play) analyser.connect(audioContext.destination);\n\n  harker.speaking = false;\n\n  harker.suspend = function() {\n    return audioContext.suspend();\n  }\n  harker.resume = function() {\n    return audioContext.resume();\n  }\n  Object.defineProperty(harker, 'state', { get: function() {\n    return audioContext.state;\n  }});\n  audioContext.onstatechange = function() {\n    harker.emit('state_change', audioContext.state);\n  }\n\n  harker.setThreshold = function(t) {\n    threshold = t;\n  };\n\n  harker.setInterval = function(i) {\n    interval = i;\n  };\n\n  harker.stop = function() {\n    running = false;\n    harker.emit('volume_change', -100, threshold);\n    if (harker.speaking) {\n      harker.speaking = false;\n      harker.emit('stopped_speaking');\n    }\n    analyser.disconnect();\n    sourceNode.disconnect();\n  };\n  harker.speakingHistory = [];\n  for (var i = 0; i < history; i++) {\n      harker.speakingHistory.push(0);\n  }\n\n  // Poll the analyser node to determine if speaking\n  // and emit events if changed\n  var looper = function() {\n    setTimeout(function() {\n\n      //check if stop has been called\n      if(!running) {\n        return;\n      }\n\n      var currentVolume = getMaxVolume(analyser, fftBins);\n\n      harker.emit('volume_change', currentVolume, threshold);\n\n      var history = 0;\n      if (currentVolume > threshold && !harker.speaking) {\n        // trigger quickly, short history\n        for (var i = harker.speakingHistory.length - 3; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history >= 2) {\n          harker.speaking = true;\n          harker.emit('speaking');\n        }\n      } else if (currentVolume < threshold && harker.speaking) {\n        for (var i = 0; i < harker.speakingHistory.length; i++) {\n          history += harker.speakingHistory[i];\n        }\n        if (history == 0) {\n          harker.speaking = false;\n          harker.emit('stopped_speaking');\n        }\n      }\n      harker.speakingHistory.shift();\n      harker.speakingHistory.push(0 + (currentVolume > threshold));\n\n      looper();\n    }, interval);\n  };\n  looper();\n\n  return harker;\n}\n"],
  "mappings": "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",
  "names": ["i", "history"]
}
